---
title: 22. Strange HTTP Headers
updated: 2025-09-17 04:23:31Z
created: 2025-09-17 04:20:15Z
---

&nbsp;

# Strange HTTP Headers and Request Manipulation

At first glance, web server traffic may look normal. But even when fuzzing or brute-force attacks aren’t obvious, subtle anomalies in HTTP headers can reveal malicious activity. Attackers often manipulate request headers to bypass security controls or access restricted resources.

Typical signs of suspicious requests include:

- **Weird `Host` headers** (e.g., `Host: 127.0.0.1` or `Host: admin`)
    
- **Unusual HTTP verbs** (e.g., `OPTIONS`, `TRACE`, or non-standard verbs)
    
- **Changed or spoofed `User-Agent` strings**
    

* * *

## Finding Suspicious Host Headers

### Step 1: Focus on HTTP Traffic

In Wireshark, filter for HTTP traffic: `http`

This lets you see client-server communication clearly, such as requests for login pages or file parameters.

### Step 2: Exclude Legitimate Hosts

To find irregular `Host` headers, use a filter that removes normal traffic:

`http.request and (!(http.host == "192.168.10.7"))`

- Replace the IP with your server’s real address or domain.
    
- Any results that remain are **suspicious** since they target your server but with altered headers.
    

### Step 3: Investigate Odd Host Values

Attackers often try:

- `Host: 127.0.0.1` — hoping to trick the server into treating them as “localhost.”
    
- `Host: admin` — trying to access virtual hosts or misconfigured back-end apps.
    

Such manipulations are usually performed with proxy tools like **Burp Suite**.

### Defense

- Verify **virtual host** and **reverse proxy configurations** are strict.
    
- Keep your **web server fully patched**.
    

* * *

## Detecting Bad Requests (Code 400) and Request Smuggling

### Why 400 Errors Matter

HTTP `400 Bad Request` responses can be a red flag. While they sometimes result from typos or buggy clients, attackers deliberately trigger them during **fuzzing** or **request smuggling** attempts.

Filter for these with:

`http.response.code == 400`

* * *

## Example: CRLF Injection / HTTP Request Smuggling

An attacker might send an encoded request like this:

```php
GET%20%2flogin.php%3fid%3d1%20HTTP%2f1.1%0d%0aHost%3a%20192.168.10.5%0d%0a%0d%0a
GET%20%2fuploads%2fcmd2.php%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%3a8080%0d%0a%0d%0a
 HTTP%2f1.1 Host: 192.168.10.5

```

When decoded, the server interprets this as **multiple requests inside one packet**:

```php
GET /login.php?id=1 HTTP/1.1
Host: 192.168.10.5

GET /uploads/cmd2.php HTTP/1.1
Host: 127.0.0.1:8080

HTTP/1.1
Host: 192.168.10.5

```

If the server is vulnerable:

1.  The **first request** (`/login.php`) works as expected.
    
2.  The **second request** (`/uploads/cmd2.php`) sneaks through — possibly targeting internal services.
    
3.  This bypasses access controls, giving attackers unintended privileges.
    

* * *

## Why This Happens

Misconfigured reverse proxy or virtual host rules may allow request splitting. For example, in Apache:

```php
<VirtualHost *:80>
    RewriteEngine on
    RewriteRule "^/categories/(.*)" "http://192.168.10.100:8080/categories.php?id=$1" [P]
    ProxyPassReverse "/categories/" "http://192.168.10.100:8080/"
</VirtualHost>

```

This setup could be abused in **CVE-2023-25690**, a known Apache HTTPD vulnerability involving request smuggling.

* * *

## Indicators of Success

- **400 responses** → signs of probing / failed smuggling attempts.
    
- **200 responses after suspicious requests** → attacker may have successfully bypassed controls.
    

* * *

## Key Takeaways

1.  Always check **Host headers** for anomalies.
    
2.  Watch for **400 Bad Request** codes — they may reveal attack attempts.
    
3.  Validate and harden **proxy / vhost configurations**.
    
4.  Patch your server against known flaws (e.g., **CVE-2023-25690**).
    
5.  Combine **detection** (traffic analysis) with **prevention** (secure configs).
    

* * *

&nbsp;