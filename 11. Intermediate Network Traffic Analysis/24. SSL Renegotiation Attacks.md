---
title: 24. SSL Renegotiation Attacks
updated: 2025-09-18 03:24:27Z
created: 2025-09-18 03:07:31Z
---

## Background: Why SSL/TLS Matters

- **HTTP** is plaintext and stateless — attackers can read and modify traffic.
    
- **HTTPS (HTTP over SSL/TLS)** adds:
    
    - **Confidentiality** (encryption prevents eavesdropping).
        
    - **Integrity** (messages can’t be tampered with undetected).
        
    - **Authentication** (server proves its identity with certificates).
        

The handshake process ensures both client and server agree on encryption parameters and derive session keys for symmetric encryption (faster than pure asymmetric crypto).

* * *

## SSL/TLS Handshake Process Recap

1.  **Client Hello** – Client proposes:
    
    - Protocol versions it supports (e.g., TLS 1.0–1.3).
        
    - List of supported ciphersuites.
        
    - A random nonce (used later for key derivation).
        
2.  **Server Hello** – Server chooses:
    
    - Protocol version (from client’s list).
        
    - Cipher suite (from client’s proposals).
        
    - Another random nonce.
        
3.  **Certificate Exchange** – Server sends its certificate (with its public key).
    
4.  **Key Exchange** – Client generates a premaster secret, encrypts it with server’s public key, and sends it.
    
    - In Diffie-Hellman-based key exchange, both sides share public/private DH keys.
5.  **Session Key Derivation** – Both compute the same session keys from premaster secret + nonces.
    
6.  **Finished Messages** – Both confirm they derived identical keys.
    
7.  **Secure Data Exchange** – Encrypted traffic begins.
    

Normally, this is **done once per session**.

**We can also look at this from a general algorithmic perspective.**

```txt
Handshake Step 			Relevant Calculations

Client Hello 		ClientHello = { ClientVersion, ClientRandom, Ciphersuites, CompressionMethods }
Server Hello 		ServerHello = { ServerVersion, ServerRandom, Ciphersuite, CompressionMethod }
Certificate Exchange    ServerCertificate = { ServerPublicCertificate }

Key Exchange 	
   			ClientDHPrivateKey
    			ClientDHPublicKey = DH_KeyGeneration(ClientDHPrivateKey)
    			ClientKeyExchange = { ClientDHPublicKey }
    			ServerDHPrivateKey
    			ServerDHPublicKey = DH_KeyGeneration(ServerDHPrivateKey)
    			ServerKeyExchange = { ServerDHPublicKey }
    
Premaster Secret 
    			PremasterSecret = DH_KeyAgreement(ServerDHPublicKey, ClientDHPrivateKey)
    			PremasterSecret = DH_KeyAgreement(ClientDHPublicKey, ServerDHPrivateKey)
    
Session Key Derivation 	
    			MasterSecret = PRF(PremasterSecret, "master secret", ClientNonce + ServerNonce)
    			KeyBlock = PRF(MasterSecret, "key expansion", ServerNonce + ClientNonce) 
       
Extraction of Session Keys 	
    			ClientWriteMACKey = First N bytes of KeyBlock
    			ServerWriteMACKey = Next N bytes of KeyBlock
    			ClientWriteKey = Next N bytes of KeyBlock
    			ServerWriteKey = Next N bytes of KeyBlock
    			ClientWriteIV = Next N bytes of KeyBlock
    			ServerWriteIV = Next N bytes of KeyBlock
    
Finished Messages       FinishedMessage = PRF(MasterSecret, "finished", Hash(ClientHello + ServerHello))



```

* * *

## What Is SSL Renegotiation?

- SSL/TLS allows **renegotiation of encryption parameters mid-session**.
    
- This feature was originally intended to:
    
    - Refresh keys periodically for long-lived connections.
        
    - Allow switching cipher suites.
        
    - Support client authentication after the initial handshake.
        

But attackers abuse this feature.

* * *

## SSL Renegotiation Attack Explained

**An attacker can repeatedly trigger renegotiations**, forcing the server to redo expensive cryptographic operations (handshake). This leads to:

### 1\. **DoS (Denial of Service)**

- Each renegotiation consumes CPU and memory on the server.
    
- A client sending hundreds/thousands of renegotiation requests can overwhelm the server.
    
- It’s especially dangerous if asymmetric crypto (RSA key exchange) is used — CPU-intensive.
    

### 2\. **Cipher Downgrade Attack**

- By repeatedly forcing renegotiation, the attacker tries to make the server agree to a weaker cipher suite.
    
- Example: Downgrade from TLS 1.2 AES-256 to SSLv3 RC4 (if supported).
    
- Weak ciphers can then be cracked or exploited.
    

### 3\. **Cryptanalysis Vector**

- Repeated renegotiation exposes multiple handshake attempts.
    
- An attacker can capture these to look for implementation flaws or patterns.
    

* * *

## Indicators in Traffic (Wireshark/PCAP Analysis)

When analyzing `SSL_renegotiation_edited.pcapng`, key signs include:

### **1\. Multiple Client Hello Messages**

- In normal traffic: **1 Client Hello → 1 Server Hello → Handshake → Data**.
    
- In attacks: **many Client Hellos from the same client in rapid succession**.
    

Filter: `ssl.record.content_type == 22`

### **2\. Out-of-Order Handshakes**

- Seeing a **Client Hello after encrypted data exchange** is suspicious.
    
- Normally, handshakes don’t repeat unless session resumption is explicitly used.
    

### **3\. Server Resource Spikes**

- If analyzing logs in parallel: CPU spikes, SSL library errors, and dropped connections may appear.

* * *

## Practical Attack Scenarios

1.  **DoS Example**  
    Attacker opens a connection and repeatedly sends renegotiation requests → server chokes.  
    (Similar to Slowloris but at SSL/TLS level.)
    
2.  **Downgrade Example**  
    Attacker interferes with renegotiation → forces fallback to SSLv3 (exploitable via POODLE).
    
3.  **Injection Example (2009 TLS Renegotiation Vulnerability)**
    
    - Old flaw (CVE-2009-3555).
        
    - Attacker injects plaintext into renegotiated sessions.
        
    - Example: prefixing attacker-controlled data into an HTTPS request stream.
        

* * *

## Defenses & Mitigations

- **Disable SSL renegotiation** unless absolutely required.
    
- **Use secure TLS versions (≥ TLS 1.2)** with strong ciphers.
    
- **Patch SSL libraries** — OpenSSL, GnuTLS, etc., fixed renegotiation flaws years ago.
    
- **Rate limit renegotiations** to prevent DoS.
    
- **Prefer TLS session resumption** over renegotiation.
    

* * *

## Heartbleed (Side Note)

- Different vulnerability (**CVE-2014-0160**).
    
- Exploits the TLS heartbeat extension.
    
- Allows attackers to read memory (leak private keys, passwords).
    
- Not renegotiation-related, but often studied together as SSL/TLS weaknesses.
    

* * *

**In short:**  
An **SSL renegotiation attack** abuses the renegotiation feature to either exhaust server resources (DoS), downgrade ciphers, or open cryptanalysis avenues. In Wireshark, the biggest red flag is **multiple Client Hellos mid-session**.

&nbsp;