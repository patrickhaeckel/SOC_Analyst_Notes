---
title: 20. Functions
updated: 2025-10-13 17:58:18Z
created: 2025-10-13 05:12:00Z
---

## Understanding Functions in Assembly

So far, we’ve learned about **branching** and **control flow instructions** that determine how a program executes. We also saw how **procedures** work — reusable blocks of code that can be called from different places.  
Now, let’s focus on **functions**, which are a specialized type of procedure that usually handle arguments, return values, and register preservation.

* * *

## 1\. Function Calling Convention

When calling a function in assembly, certain **rules** must be followed to ensure both the caller and callee understand how to exchange information. These rules are called a **calling convention**.

In 64-bit Linux (System V AMD64 ABI), the function-calling convention defines:

1.  **Caller-Saved Registers** – The caller must save any registers it wants to preserve before calling a function (e.g., `rax`, `rcx`, `rdx`, `rsi`, `rdi`, `r8–r11`).
    
2.  **Passing Arguments** – Function arguments are passed in registers in a specific order:
    
    - 1st → `rdi`
        
    - 2nd → `rsi`
        
    - 3rd → `rdx`
        
    - 4th → `rcx`
        
    - 5th → `r8`
        
    - 6th → `r9`
        
    - Additional arguments go on the **stack**.
        
3.  **Stack Alignment** – Before calling a function, the **stack pointer (`rsp`)** must be aligned to a **16-byte boundary**.
    
4.  **Return Value** – Functions return values in the `rax` register.
    

These steps are similar to making a **syscall**, except:

- For syscalls, the syscall number goes in `rax`.
    
- For function calls, we simply use the instruction `call function_name`.
    
- Syscalls handle stack alignment automatically; functions don’t.
    

* * *

## 2\. Writing Functions

When writing your own function (the **callee**), you need to handle the other side of the convention:

1.  **Save Callee-Saved Registers** – Preserve registers like `rbx`, `rbp`, and `r12–r15` if you modify them.
    
2.  **Retrieve Arguments** – Use the registers (`rdi`, `rsi`, etc.) to get function parameters.
    
3.  **Align the Stack** – Ensure `rsp` is aligned properly.
    
4.  **Return the Value** – Place the return value in `rax`.
    

These rules are typically handled in two parts:

- **Prologue** – Code that prepares the stack and saves registers.
    
- **Epilogue** – Code that restores the stack and registers before returning.
    

In this lesson, we’ll focus only on **calling existing functions**, not writing our own.

* * *

## 3\. Using External Functions (like `printf`)

Instead of writing our own complex routines (e.g., converting integers to ASCII), we can use existing **C library (libc)** functions like `printf`.

The `printf` function can handle integer formatting for us. To use it:

1.  Declare it as **external**.
    
2.  Link against the **libc dynamic library** when building the program.
    

Example:

```
global _start
extern printf

```

This lets us call `printf` just like a normal function.

* * *

## 4\. Saving Registers Before the Call

We’ll define a procedure called `printFib` to call `printf`.  
First, we save the registers we’ll use to prevent overwriting them:

```
printFib:
    push rax        ; push registers to stack
    push rbx
    ; function call
    pop rbx         ; restore registers from stack
    pop rax
    ret
```

* * *

## 5\. Passing Arguments to `printf`

Let’s check `printf`’s signature with:

`man -s 3 printf`

It shows:

`int printf(const char *format, ...);`

This means:

- The **first argument** is a pointer to a format string.
    
- The **next arguments** are the values to be printed.
    

So, if we want to print an integer followed by a newline, we can define:

```
section .data
    outFormat db "%d", 0x0a, 0x00 ; "%d\n" + null terminator

```

Then we pass:

- `rdi = outFormat` (format string)
    
- `rsi = rbx` (Fibonacci number)
    

Example:

```
printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    pop rbx             ; restore registers from stack
    pop rax
    ret
```

* * *

## 6\. Stack Alignment

Before calling a function, ensure that `rsp` (the stack pointer) is aligned to a **16-byte boundary**.  
This is necessary because many library functions (like those in libc) assume this alignment for performance reasons — and will crash otherwise.

Each:

- `push` adds **8 bytes**.
    
- `call` pushes the return address (**8 bytes**).
    

If you’ve pushed an odd number of registers, you’ll misalign the stack.  
To fix it, subtract bytes from `rsp` so the total pushed is a multiple of 16:

```
sub rsp, 8     ; adjust stack alignment if needed
call printf
add rsp, 8

```

* * *

## 7\. Full Example: Fibonacci with `printf`

```
global  _start
extern  printf

section .data
    message db "Fibonacci Sequence:", 0x0a
    outFormat db  "%d", 0x0a, 0x00

section .text
_start:
    call printMessage   ; print intro message
    call initFib        ; set initial Fib values
    call loopFib        ; calculate Fib numbers
    call Exit           ; Exit the program

printMessage:
    mov rax, 1           ; rax: syscall number 1
    mov rdi, 1          ; rdi: fd 1 for stdout
    mov rsi, message    ; rsi: pointer to message
    mov rdx, 20          ; rdx: print length of 20 bytes
    syscall             ; call write syscall to the intro message
    ret

initFib:
    xor rax, rax        ; initialize rax to 0
    xor rbx, rbx        ; initialize rbx to 0
    inc rbx             ; increment rbx to 1
    ret

printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    call printf         ; printf(outFormat, rbx)
    pop rbx             ; restore registers from stack
    pop rax
    ret

loopFib:
    call printFib       ; print current Fib number
    add rax, rbx        ; get the next number
    xchg rax, rbx       ; swap values
    cmp rbx, 10		    ; do rbx - 10
    js loopFib		    ; jump if result is <0
    ret

Exit:
    mov rax, 60
    mov rdi, 0
    syscall

```

* * *

## 8\. Linking with libc

Since we’re using `printf` from the C standard library, we must dynamically link our program to `libc`:

```
nasm -f elf64 fib.s
ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2
./fib

```

Output:

```
1
1
2
3
5
8

```

* * *

## Summary

| Step | Purpose | Key Registers |
| --- | --- | --- |
| Save registers | Prevent data loss across calls | `push`, `pop` |
| Pass arguments | Provide input to the function | `rdi`, `rsi`, ... |
| Align stack | Ensure performance/stability | `rsp` multiple of 16 |
| Call function | Execute it | `call printf` |
| Return value | Function result | `rax` |

* * *

&nbsp;