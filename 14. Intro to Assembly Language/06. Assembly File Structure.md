---
title: 06. Assembly File Structure
updated: 2025-10-09 06:33:22Z
created: 2025-10-07 00:27:56Z
---

&nbsp;

## 1\. The Big Picture — What an Assembly File Is

An **Assembly file** (usually `.asm`) is divided into **sections** that represent how the program will be stored in memory when it runs

Each section has a specific purpose:

| Section | Purpose | Memory Type |
| --- | --- | --- |
| `.data` | Stores variables (data you define) | Read/Write |
| `.text` | Stores instructions (the actual code) | Read/Only |
| `.bss` *(optional)* | Reserves space for variables without initializing them | Read/Write |

When you **assemble** and **link** the file, these sections are mapped into memory — the `.text` section becomes your **executable code**, and `.data` becomes your **program’s stored data**.

* * *

## 2\. The Template Example

Here’s your sample “Hello World!” program again:

```
global  _start

section .data
message: db "Hello HTB Academy!"

section .text
_start:
    mov     rax, 1
    mov     rdi, 1
    mov     rsi, message
    mov     rdx, 18
    syscall

    mov     rax, 60
    mov     rdi, 0
    syscall

```

This program prints `"Hello HTB Academy!"` and then exits.

* * *

## 3\. Directives (Assembler Instructions)

Directives tell the **assembler** (not the CPU) how to build the program.

| Directive | Purpose |
| --- | --- |
| `global _start` | Tells the assembler that `_start` is the program’s entry point. When you run the program, execution begins here. |
| `section .data` | Starts the data section — where you define variables. |
| `section .text` | Starts the code section — where you write instructions that the CPU executes. |

These aren’t “commands” for the CPU — they’re **meta instructions** that control how your program is assembled.

* * *

## 4\. The `.data` Section — Variables

```
section .data
message: db "Hello HTB Academy!"

```

- `message:` → label (marks a memory address)
    
- `db` → define byte(s)
    
- `"Hello HTB Academy!"` → the data (string)
    

**This creates a variable called `message`** that stores all the ASCII bytes of that string in memory.

If you added: `length equ $ - message`

then `length` becomes a **constant** (not a variable) equal to the number of bytes in `"Hello HTB Academy!"`.

`equ` = “equate”  
`$` = “current memory address”

So `$ - message` = (current position) – (start of message) → the string’s length.

* * *

## 5\. The `.text` Section — Code (Instructions)

```
section .text
_start:
    mov     rax, 1
    mov     rdi, 1
    mov     rsi, message
    mov     rdx, 18
    syscall

```

### What’s happening:

This is the **code** that executes when the program starts.

| Line | Meaning |
| --- | --- |
| `_start:` | Label — the program begins here. |
| `mov rax, 1` | System call number 1 = `write`. |
| `mov rdi, 1` | File descriptor 1 = `stdout` (the screen). |
| `mov rsi, message` | Address of the message (string to print). |
| `mov rdx, 18` | Number of bytes to print (the length of the message). |
| `syscall` | Ask the kernel to perform the system call (`write`). |

Then the next lines exit the program:

```
mov rax, 60   ; syscall number 60 = exit
mov rdi, 0    ; exit code 0 (success)
syscall

```

* * *

## 6\. Labels, Instructions, and Operands

Each line of assembly can have **three parts**:

| Part | Meaning | Example |
| --- | --- | --- |
| Label | A name marking a memory address | `_start:` or `message:` |
| Instruction | The operation to perform | `mov`, `syscall`, `add`, etc. |
| Operand(s) | The data or registers the instruction uses | `mov rax, 1` |

Example:

`_start: mov rax, 1`

- `_start:` = label
    
- `mov` = instruction
    
- `rax, 1` = operands (destination, source)
    

* * *

## 7\. Why Sections Are Separate

This is not just organization — it’s **security and memory design**:

| Section | Access Type | Purpose |
| --- | --- | --- |
| `.text` | Read-Only, Executable | CPU instructions go here |
| `.data` | Read/Write | Holds data and variables |
| `.bss` | Read/Write | Uninitialized data |
| Stack | Read/Write | Function calls and local vars |

This separation prevents malicious code from, for example, writing executable instructions into the data section (which would be a **buffer overflow attack**).

* * *

## 8\. Comments

Assembly comments start with a **semicolon `;`**.  
Everything after `;` on the same line is ignored.

Example:

```
mov rax, 1     ; write syscall
mov rdi, 1     ; file descriptor = stdout
mov rsi, message ; address of string
mov rdx, 18    ; number of bytes to write
syscall

```

* * *

## 9\. Summary — The Skeleton of Every Assembly File

Here’s the **template** you’ll see in almost every NASM program:

```
global _start         ; Tell assembler where the program begins

section .data         ; Define your variables here
message db "Hello!", 0x0a
length  equ $ - message

section .text         ; Define your code here
_start:
    mov rax, 1        ; write syscall
    mov rdi, 1        ; stdout
    mov rsi, message  ; address of message
    mov rdx, length   ; message length
    syscall

    mov rax, 60       ; exit syscall
    mov rdi, 0        ; exit code 0
    syscall

```

&nbsp;