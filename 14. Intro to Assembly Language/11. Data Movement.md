---
title: 11. Data Movement
updated: 2025-10-10 03:18:58Z
created: 2025-10-10 02:33:10Z
---

## Data Movement in x86-64 Assembly

Data movement instructions are foundational — they copy or exchange data between registers, memory, and immediate values.

### Main Instructions

| Instruction | Description | Example |
| --- | --- | --- |
| `mov` | Copy data or load immediate value | `mov rax, 1` → `rax = 1` |
| `lea` | Load the **address** of a value (not the value itself) | `lea rax, [rsp+5]` → `rax = rsp + 5` |
| `xchg` | Swap data between two operands | `xchg rax, rbx` → values exchanged |

* * *

## 1\. Moving Data (`mov`)

Example — initialize Fibonacci sequence:

```
global _start
section .text
_start:
    mov rax, 0      ; F0 = 0
    mov rbx, 1      ; F1 = 1

```

In GDB, you’ll see:

| Step | \$rax | \$rbx |
| --- | --- | --- |
| After `mov rax, 0` | 0   | 0   |
| After `mov rbx, 1` | 0   | 1   |

**Key Point:**  
`mov` **copies** data; the source remains unchanged.

* * *

## 2\. Loading Immediate Data

`mov` can load an immediate value into a register:

- `mov rax, 1` → loads 64-bit `0x0000000000000001`
    
- `mov al, 1` → loads 8-bit `0x01`
    

**Efficiency Tip:**  
Use a register that matches the data size. For example:

```
mov rax, 0
mov rbx, 1
mov bl, 1

```

`objdump` shows:

| Address | Instruction | Bytes |
| --- | --- | --- |
| 0x0 | `mov eax,0x0` | 5   |
| 0x5 | `mov ebx,0x1` | 5   |
| 0xa | `mov bl,0x1` | 2   |

Smaller registers generate smaller shellcode — critical for shellcoding.

Optimized version:

```
global _start
section .text
_start:
    mov al, 0
    mov bl, 1

```

* * *

## 3\. Exchanging Data (`xchg`)

`xchg` swaps register values directly:

`xchg rax, rbx`

After execution, `rax` and `rbx` trade contents.

* * *

## 4\. Address Pointers

Registers like `rsp`, `rbp`, and `rip` often hold **addresses** (pointers), not immediate values.

Example in GDB:

| Register | Value | Points to |
| --- | --- | --- |
| `rsp` | `0x00007fffffffe490` | `0x0000000000000001` |
| `rip` | `0x0000000000401000` | `<_start+0>` |

* * *

## 5\. Moving Pointer Values

Difference between moving a **pointer** and **dereferencing** it:

```
mov rax, rsp      ; rax = address in rsp
mov rax, [rsp]    ; rax = value stored at address rsp points to

```

| Instruction | Result |
| --- | --- |
| `mov rax, rsp` | `rax = 0x7fffffffe490` (pointer) |
| `mov rax, [rsp]` | `rax = 0x1` (value at pointer) |

**Square brackets `[]`** dereference memory.  
Offsets like `[rsp+10]` access memory at a displacement.

* * *

## 6\. Loading Value Pointers (`lea`)

`lea` (**Load Effective Address**) loads the address of a value, not the value itself.

```
lea rax, [rsp+10]   ; rax = address rsp + 10
mov rax, [rsp+10]   ; rax = value at (rsp + 10)

```

| Instruction | Meaning | Result |
| --- | --- | --- |
| `lea rax, [rsp+10]` | Load **address** offset | `rax = rsp + 10` |
| `mov rax, [rsp+10]` | Load **value** at offset | `rax = *[rsp+10]` |

**Usage Difference:**

- Use `lea` when you need the **pointer** to a value (e.g., for system calls like `write`).
    
- Use `mov` when you need the **actual value**.
    

**Note:**  
Assembler (like NASM) usually infers data size automatically (`mov rax, QWORD PTR [rsp]`).

* * *

### Summary Table

| Purpose | Instruction | Effect |
| --- | --- | --- |
| Copy data or immediates | `mov` | Loads values |
| Swap two operands | `xchg` | Exchanges data |
| Load pointer address | `lea` | Loads computed address |
| Dereference pointer | `mov [reg]` | Loads data from memory |

* * *

&nbsp;