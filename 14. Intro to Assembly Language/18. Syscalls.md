---
title: 18. Syscalls
updated: 2025-10-13 04:47:04Z
created: 2025-10-13 03:51:43Z
---

## Understanding Syscalls in Assembly

### 1\. What Are Syscalls?

Even though Assembly gives us direct access to CPU instructions, we don’t need to handle every operation manually — especially those that involve hardware like the screen, keyboard, or storage devices.

A **system call (syscall)** is a special way for a user program to **request a service from the operating system kernel**.  
In simple terms: **syscalls are built-in functions provided by the kernel** that let your program do things like read files, write to the screen, or exit cleanly — without manually talking to the hardware.

* * *

### 2\. Why We Need Syscalls

Without syscalls, writing a single character to the screen would involve:

- Sending data directly to the video memory or video I/O ports
    
- Handling text encoding and display control signals
    
- Waiting for hardware confirmation
    

That would make even small programs huge and complex. Syscalls solve this by giving us **standardized kernel functions** to do these operations safely and efficiently.

* * *

### 3\. Syscalls in Linux

In Linux, each syscall has a **unique number** and a defined **set of arguments**.  
<br/>You can find the syscall numbers in this file:

`cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h`

```
#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
#define __NR_fstat 5
```

The above file sets the syscall number for each syscall to refer to that syscall using this number.

Here, `__NR_write` has the syscall number `1`.  
So when we set `rax = 1` and call the `syscall` instruction, the kernel knows we want to execute the `write` syscall.

> **Note:**  
> For 32-bit systems, syscall numbers are stored in `unistd_32.h` instead.

* * *

### 4\. The `write` Syscall

Let’s use the `write` syscall to print text to the screen.  
We can check its arguments using the `man` command:

`man -s 2 write`

It shows: `ssize_t write(int fd, const void *buf, size_t count);`

This means the syscall expects:

| Argument | Purpose | Example |
| --- | --- | --- |
| `fd` | File descriptor (1 = stdout) | `1` |
| `buf` | Memory address of the string to be printed | Pointer to `"Fibonacci Sequence:\n"` |
| `count` | Number of bytes to write. The length we want to print | `20` |

* * *

### 5\. Syscall Calling Convention

To call a syscall, registers must be loaded with specific values in the following order (for x86_64):

| Description | 64-bit Register | 8-bit Register |
| --- | --- | --- |
| Syscall Number/Return value | `rax` | `al` |
| Callee Saved | `rbx` | `bl` |
| 1st arg | `rdi` | `dil` |
| 2nd arg | `rsi` | `sil` |
| 3rd arg | `rdx` | `dl` |
| 4th arg | `rcx` | `cl` |
| 5th arg | `r8` | `r8b` |
| 6th arg | `r9` | `r9b` |

**`rax` also holds the return value after the syscall executes.**

* * *

### 6\. Example: Writing Text to the Screen

```
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a  ; String + newline

section .text
_start:
    mov rax, 1       ; Syscall number for write()
    mov rdi, 1       ; File descriptor 1 (stdout)
    mov rsi, message ; Address of our string
    mov rdx, 20      ; Length of string
    syscall           ; Execute write()

```

When this runs, the kernel writes the message to the terminal.

* * *

### 7\. Properly Exiting the Program

If you run the above code as-is, it ends with a **segmentation fault** — because there’s no proper exit syscall.  
We can fix this by adding the **exit syscall**.

To find its number: `grep exit /usr/include/x86_64-linux-gnu/asm/unistd_64.h`

Result: `#define __NR_exit 60`

And checking its arguments: `man -s 2 exit`

Output: `void _exit(int status);`

It takes one argument: an **exit status code** (`0` for success).

* * *

### 8\. Final Working Example

```
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a

section .text
_start:
    mov rax, 1       ; Syscall number: write
    mov rdi, 1       ; File descriptor: stdout
    mov rsi, message ; Address of message
    mov rdx, 20      ; Message length
    syscall           ; Call write()

    xor rax, rax      ; Initialize registers
    xor rbx, rbx
    inc rbx           ; rbx = 1

loopFib:
    add rax, rbx
    xchg rax, rbx
    cmp rbx, 10
    js loopFib

    mov rax, 60       ; Syscall number: exit
    mov rdi, 0        ; Exit code 0 (success)
    syscall           ; Exit program

```

Now the program:

- Prints “Fibonacci Sequence:”
    
- Loops through a few Fibonacci calculations
    
- Exits **cleanly** with status code 0
    

You can verify the exit code: `echo $?`

Output: `0`

* * *

&nbsp;