---
title: 23. Shellcoding Techniques
updated: 2025-10-28 04:25:21Z
created: 2025-10-15 01:50:05Z
---

# Shellcoding Techniques — clearer, shorter, and actionable

Below is a tighter, more structured explanation of the same material with concrete steps, short rationale, and easy-to-follow examples so you can turn ordinary assembly into real shellcode.

* * *

## 1) What a shellcode *must* be

A shellcode is machine code that will be placed into memory and executed as-is. To work reliably it must meet three constraints:

1.  No external variables (no `.data` / `.bss` references).
    
2.  No absolute addresses embedded in the code.
    
3.  No NULL bytes (0x00) inside the byte sequence.
    

If any of those fail, the code can break when copied into memory or when processed by string-based loaders/dissectors.

* * *

## 2) Why each requirement matters (brief)

1.  Text segment is executable but not writable; data segment is writable but not executable. If you rely on `.data` you usually break on execution in many environments.
    
2.  Absolute addresses are only valid in one process image; a shellcode must be position-independent.
    
3.  NULL bytes often act as string terminators (or break copy routines that stop at 0x00), so many injection methods will truncate the payload.
    

* * *

## 3) Techniques and recipes

### A — Remove variables (keep everything in `.text`)

Goal: embed any data (strings, constants) where the code can access it without referencing the data segment.

Options:

1.  Move small immediates directly into registers (when it fits).  
    Example (64-bit): `mov rax, 0x1122334455667788` (but watch for NULLs).
    
2.  Build strings on the stack: push parts (in reverse), then use `rsp` as pointer.  
    Pattern:
    
    1.  Prepare 8-/4-byte chunks (avoid NULLs — see below).
        
    2.  Push them (last chunk first).
        
    3.  `mov rsi, rsp` → rsi points at the assembled string.
        
3.  Use registers as temporary storage for pushes if immediate push size is limited:
    
    - `xor rbx, rbx` ; `mov bx, 'y!'` ; `push rbx` — zero `rbx`, fill the low part, push.

Notes:

- 64-bit registers hold 8 bytes. If a chunk is smaller, zero the register first then write the smaller-size register (to avoid leftover bytes).
    
- You can avoid a NUL terminator by providing the length to `write` syscall.
    

### B — Remove addresses (be position-independent)

Goal: do not bake absolute addresses into code.

How:

1.  Use labels and relative calls/jumps. Assemblers translate labels into RIP-relative operands when appropriate. That makes your code relocatable.
    
2.  For runtime data access, use `rsp` (stack) or calculate addresses RIP-relative (e.g., `lea rsi, [rip + message]`) — assembly will encode it relative to RIP.
    

### C — Remove NULL bytes (no 0x00)

Goal: ensure no 0x00 bytes occur in machine code.

Sources of NULLs:

- Moving a small immediate into a large register (`mov rax, 1`) pads with zeros.
    
- Large immediates that contain 0x00 bytes.
    

Strategies:

1.  Use the smallest register width that covers the value:
    
    - Instead of `mov rax, 1`, do `xor rax, rax` then `mov al, 1`. That produces shorter, NULL-free opcodes.
2.  Zero registers using `xor reg, reg` rather than `mov reg, 0`.
    
3.  Build values incrementally where possible (e.g., `xor rax, rax` then `add al, 60` instead of `mov rax, 60`).
    
4.  When storing text bytes, assemble them as ASCII bytes that do not contain 0x00 (or split/encode them so nop-safe).
    
5.  If you must embed a value that would generate NULLs, encode it (e.g., XOR-encode) and decode at runtime — but that increases complexity.
    

* * *

## 4) Walk-through: transform a hello-world program into NULL-free shellcode

Original (non-shellcode-friendly):

```
section .data
  message db "Hello HTB Academy!"
section .text
_start:
  mov rsi, message
  mov rdi, 1
  mov rdx, 18
  mov rax, 1
  syscall
  mov rax, 60
  mov rdi, 0
  syscall

```

Problems:

- Uses `.data` (`message`) → not self-contained in `.text`.
    
- `mov rax, 1` and others expand to NULL-padded machine code.
    

Refactor steps applied:

1.  Build the string on the stack (push in reverse, in chunks). Use `xor` to zero registers and small registers (`bx`, `al`, `dl`, etc.) to avoid NULLs.
    
2.  Use `mov rsi, rsp` to point to the string.
    
3.  Use `xor` + small-register writes for syscalls to avoid padding zeros.
    
4.  Use `add al, 60` after `xor rax, rax` to set exit code 60 without embedding NULLs.
    

Resulting assembly (annotated, minimal):

```
global _start
section .text
_start:
    xor rbx, rbx
    mov bx, 'y!'        ; 2 bytes into bx
    push rbx
    mov rbx, 'B Academ' ; fits into 8 bytes chunk
    push rbx
    mov rbx, 'Hello HT' ; fits into 8 bytes chunk
    push rbx
    mov rsi, rsp        ; rsi -> "Hello HTB Academy!"

    xor rax, rax
    mov al, 1           ; syscall: write
    xor rdi, rdi
    mov dil, 1          ; fd = 1
    xor rdx, rdx
    mov dl, 18          ; length = 18
    syscall

    xor rax, rax
    add al, 60          ; syscall: exit (60)
    xor dil, dil        ; exit code 0
    syscall

```

Why this is good:

- Everything is in `.text` and stack — no `.data`.
    
- Uses small registers (`al`, `dl`, `dil`, `bx`) after `xor` to avoid zero-padding into 8-byte registers.
    
- Pushes are arranged so the string is contiguous on stack and addressable via `rsp`.
    

* * *

## 5) How to check your shellcode for NULLs and length (practical)

After assembling and extracting bytes, check:

Python snippet (example from your workflow):

```
shellcode = bytes.fromhex("4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05")
print(len(shellcode), "- No NULL bytes" if 0 not in shellcode else "- Found NULL byte")

```

Your example output:

`61 bytes - No NULL bytes`

Then run it with your loader to verify runtime behavior:

`python3 loader.py '<hex_shellcode>'`

Expected output:

`Hello HTB Academy!`

* * *

## 6) Quick tips & reminders

1.  Always `xor reg, reg` to clear before using a smaller sub-register to avoid leftover high bytes.
    
2.  Prefer `mov al, imm8` / `mov dl, imm8` / `mov bx, imm16` over `mov rax, imm64` where possible.
    
3.  Use stack pushes to place data and `mov reg, rsp` or `lea reg, [rip + label]` (RIP-relative) for addresses.
    
4.  If a value absolutely contains 0x00 and you cannot avoid it, consider a runtime decoder (XOR/ADD) or split the value into non-zero chunks.
    
5.  Keep shellcode as short as possible — smaller payloads are easier to inject and less likely to contain accidental NULLs.
    

* * *

&nbsp;