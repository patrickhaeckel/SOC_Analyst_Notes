---
title: 22. Shellcoding
updated: 2025-10-15 02:39:59Z
created: 2025-10-15 02:37:42Z
---

###### [](https://chatgpt.com/c/68ef08c1-46f0-832a-8d20-67d409e59295#main)Shellcode — clearer, structured explanation

Below is a tighter, clearer explanation of what shellcode is, why it matters, how it’s produced and run, and practical recipes (scripts + debugging tips). I’ve kept examples and commands from your original text but reorganized and annotated them so each step is easier to follow.

* * *

# 1) What is shellcode? (short)

1.  A shellcode is the raw machine code bytes (usually shown in hex) that implement some behavior when executed by the CPU.
    
2.  It is the byte-for-byte representation of assembled instructions (the `.text` section of a binary).
    
3.  In pentesting/binary exploitation you often inject those bytes into memory and cause the CPU to execute them (e.g., via a buffer overflow or via code injection into a process).
    

* * *

# 2) Key properties a useful shellcode must have

1.  Position independent — it must work no matter where in memory it is placed (no absolute addresses).
    
2.  Self-contained — do not depend on relocations or external initializers.
    
3.  Small and efficient — smaller payloads are easier to fit into exploit windows.
    
4.  Avoid bad bytes (commonly `0x00`, `0x0a`, `0x0d`, etc.) when the transport interprets those bytes specially.
    
5.  Properly aligned and follow calling convention expectations if interacting with libc/syscalls.
    
6.  Minimal dependencies — prefer using syscalls directly rather than large library calls.
    
7.  Non-NULL-carrying immediate constants where required (for string or pointer data you may push bytes on the stack or build them at runtime).
    

* * *

# 3) Why some extracted `.text` hex won't just “work”

1.  When you extract the `.text` section from a compiled ELF, it may contain instructions that reference absolute addresses (e.g., `mov rsi, message`) where `message` is a data address resolved by the linker.
    
2.  Those absolute addresses are correct inside the original binary layout, but if you inject those raw bytes somewhere else (or run them alone), the absolute immediates point to nowhere useful — so the shellcode fails.
    
3.  A working shellcode avoids absolute data addresses; it either constructs data at runtime, uses relative addressing, or embeds the data immediately following the code and computes offsets relative to RIP.
    

* * *

# 4) Example: assembly → shellcode → why the original failed

1.  Your simple `Hello World` program used `mov rsi, message` (an absolute move). The binary’s `.text` when taken as raw bytes contains the absolute address encoded as an immediate.
    
2.  That raw hex will only work when the code is at the exact memory layout the linker produced. If you copy that raw hex to another address and execute, the immediate address is wrong.
    
3.  The “fixed” shellcode was rewritten to be position-independent (e.g., using `call/pop` or relative data placement) and to avoid bad bytes — that’s why it runs when injected.
    

* * *

# 5) Tools & workflows (practical recipes)

## 5.1 Assemble / disassemble with pwntools (quick)

1.  Assemble a single instruction:
    
    - `pwn asm 'push rax' -c 'amd64'`  
        Output: `50` (the byte for `push rax`).
2.  Disassemble a hex byte:
    
    - `pwn disasm '50' -c 'amd64'`  
        Output: `push rax`

Notes:

- `-c 'amd64'` sets the architecture to x86_64.
    
- Use pwntools for quick conversions during development.
    

## 5.2 Extract `.text` from an ELF using pwntools

Python REPL example:

- ```
    >>> from pwn import *
    >>> file = ELF('helloworld')
    >>> file.section(".text").hex()
    '48be00...f05'
    
    ```
    
- Script (shellcoder.py):
    

```
#!/usr/bin/env python3
# Extract .text section from ELF and print as hex
import sys
from pwn import ELF, context

context(os="linux", arch="amd64", log_level="error")

if len(sys.argv) != 2:
    print("usage: shellcoder.py <binary>")
    sys.exit(1)

elf = ELF(sys.argv[1])
text = elf.section(".text")
print(text.hex())

```

- - Run: `python3 shellcoder.py helloworld`

## 5.3 Assemble a shellcode into an executable (pwntools)

Build a runnable ELF from raw bytes and mark it executable:

1.  ```
    # assembler.py
    # Usage: python3 assembler.py <hex-shellcode> <output-binary>
    import sys, os, stat
    from pwn import ELF, context, unhex
    
    context(os="linux", arch="amd64", log_level="error")
    
    if len(sys.argv) != 3:
        print("usage: assembler.py <hex-shellcode> <out>")
        sys.exit(1)
    
    shellcode = unhex(sys.argv[1])
    ELF.from_bytes(shellcode).save(sys.argv[2])
    os.chmod(sys.argv[2], os.stat(sys.argv[2]).st_mode | stat.S_IEXEC)
    
    ```
    
    - Run: `python3 assembler.py '4831db...' helloworld`
        
    - Then: `./helloworld`
        

## 5.4 Quick loader (run shellcode in a controlled process)

loader.py — loads hex shellcode into a small process with executable memory and hands you an interactive session:

1.  ```
    #!/usr/bin/env python3
    import sys
    from pwn import context, run_shellcode, unhex
    
    context(os="linux", arch="amd64", log_level="error")
    
    if len(sys.argv) != 2:
        print("usage: loader.py <hex-shellcode>")
        sys.exit(1)
    
    run_shellcode(unhex(sys.argv[1])).interactive()
    
    ```
    
    - Run: `python3 loader.py '4831db...'`
        
    - Good for quick functional tests.
        

* * *

# 6) Debugging shellcode with gdb

1.  Recommended: assemble the shellcode into an ELF (using `assembler.py`) and debug that ELF in gdb. This gives deterministic addresses and lets you set breakpoints.
    
2.  Typical gdb flow:
    
    - `gdb -q helloworld`
        
    - `b *0x401000` (break at entry point — use the ELF entry address shown by `readelf -h` or pwntools)
        
    - `r`
        
    - `disassemble /r $rip` or use your favourite gdb plugin (gef/peda).
        
3.  If you use `loader.py`, start it, find its PID, then `gdb -p PID` to attach — be mindful the process might exit quickly.
    
4.  Useful gdb commands:
    
    - `x/20bx $rip` (view next 20 bytes in hex)
        
    - `si` / `ni` (single-step instruction / next instruction)
        
    - `info regs` (inspect registers)
        
    - `set follow-fork-mode child` (if shellcode forks)
        
    - `catch syscall` (catch syscalls if your gdb supports it)
        

* * *

# 7) Common shellcoding techniques (practical patterns)

1.  RIP-relative data: put your string right after code and use `lea rsi, [rip + offset]` or `call/pop` to get address relative to RIP. This avoids absolute addresses.
    
2.  Build immediates at runtime: use `xor/shift/or/rol` sequences to construct values avoiding bad bytes.
    
3.  Push data onto the stack and point to it (push bytes in reverse then `mov rsi, rsp`).
    
4.  Use direct syscalls (on Linux `syscall` with registers set) rather than calling libc symbols. This reduces dependency on dynamic linking and is smaller.
    

* * *

# 8) Why modern systems make straight shellcoding harder

1.  NX / DEP (non-executable memory) blocks execution on writable pages.
    
2.  ASLR randomizes addresses (so absolute addresses fail).
    
3.  PIE (position-independent executables) shifts binary layout.
    
4.  Stack canaries detect stack corruption.
    
5.  Modern mitigations often force attackers to use ROP (Return-Oriented Programming) chains, memory disclosure to bypass ASLR, or gadget-chaining instead of straight injected shellcode.
    

* * *

# 9) Checklist before you try a shellcode in an exploit

1.  Is the shellcode position-independent?
    
2.  Have you removed or avoided bad bytes required by your transport?
    
3.  Does it avoid absolute addresses / relocations?
    
4.  Will the target OS/arch allow execution on the injected page (NX/DEP)?
    
5.  Does it align the stack if needed? (x86_64 syscalls expect 16-byte stack alignment before `call` into libc — check calling convention if mixing with library calls)
    
6.  Have you tested it locally with `loader.py` or an assembled ELF under `gdb`?
    

* * *

# 10) Short annotated example: reason the “bad” shellcode failed

1.  Bad shellcode (excerpt): contains `mov rsi, 0x00204000...` — the immediate contains an absolute virtual address the linker gave at compile time.
    
2.  When you take just the `.text` bytes and execute them elsewhere, that immediate points to garbage — loads wrong pointer or segfaults.
    
3.  Fix: rewrite so the data is next to code and loaded via RIP-relative addressing or reconstructed at runtime.
    

* * *

# 11) Safety & ethics (brief)

1.  Use shellcoding knowledge only in controlled labs, VulnBoxes, or with explicit authorization.
    
2.  Testing or exploiting systems without permission is illegal and unethical.
    

* * *

# 12) Quick reference commands

1.  Assemble: `pwn asm 'mov rax, 1; syscall' -c 'amd64'`
    
2.  Disassemble hex: `pwn disasm '48c7c001000000' -c 'amd64'`
    
3.  Extract .text: `python3 shellcoder.py <binary>` (script above)
    
4.  Run shellcode: `python3 loader.py '<hex-shellcode>'`
    
5.  Build ELF: `python3 assembler.py '<hex-shellcode>' out` then `gdb out`
    

* * *

&nbsp;