---
title: 19. Procedures
updated: 2025-10-13 17:08:58Z
created: 2025-10-13 05:06:21Z
---

## Understanding Procedures in Assembly

### Why We Use Procedures

As programs grow larger, it becomes inefficient to repeat the same code multiple times. To solve this, we **refactor** our code — that is, we reorganize it to be cleaner, more efficient, and easier to maintain.

One of the best ways to refactor code in assembly is by using **procedures** (also known as *subroutines*). Procedures let us group a set of related instructions under a label that we can “call” whenever we need that functionality.

This approach:

- Avoids repeating the same code.
    
- Makes the program easier to read and debug.
    
- Allows complex programs to be split into smaller, more manageable pieces.
    

* * *

### What Is a Procedure?

A **procedure** is simply a block of code that performs a specific task.  
You define a procedure using a **label**, then use the **`call`** instruction to execute it from other parts of your program.

When the CPU reaches a `call`, it:

1.  Saves the current instruction pointer (RIP) onto the **stack**.
    
2.  Jumps to the address of the called procedure.
    

When the procedure finishes, a **`ret` (return)** instruction:

1.  Pops the saved address from the stack.
    
2.  Returns control to the instruction right after the original `call`.
    

This mechanism is the foundation for **structured programming** in assembly.

* * *

### Refactoring Example: Fibonacci Program

Let’s take this basic Fibonacci example:

```
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a

section .text
_start:
    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1      ; rdi: fd 1 for stdout
    mov rsi,message ; rsi: pointer to message
    mov rdx, 20      ; rdx: print length of 20 bytes
    syscall         ; call write syscall to the intro message
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1

loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
    mov rax, 60
    mov rdi, 0
    syscall
```

This code does four main things:

1.  Prints a message.
    
2.  Initializes Fibonacci values.
    
3.  Loops to generate numbers.
    
4.  Exits the program.
    

All this logic is in one block — which makes it hard to modify or reuse.

* * *

### Step 1: Labeling Procedures

We can split the code into logical parts by labeling each section as a **procedure**:

```
printMessage:
    ; print the intro message
initFib:
    ; initialize Fibonacci values
loopFib:
    ; loop to calculate numbers
Exit:
    ; exit the program

```

At this point, the code is more organized, but still executes line by line.  
To actually make use of these labeled blocks as **procedures**, we need to use **`call`** and **`ret`**.

* * *

### Step 2: Using `CALL` and `RET`

Here’s how `call` and `ret` work:

| Instruction | Description | Example |
| --- | --- | --- |
| `call <label>` | Pushes the address of the next instruction (RIP) to the stack, then jumps to `<label>` | `call printMessage` |
| `ret` | Pops the saved address from the stack into RIP, returning to the caller | `ret` |

* * *

### Step 3: Implementing Procedures with `CALL`/`RET`

We can now refactor the main program to call each procedure in sequence:

```
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a

section .text
_start:
    call printMessage   ; print intro message
    call initFib        ; set initial Fib values
    call loopFib        ; calculate Fib numbers
    call Exit           ; Exit the program

printMessage:
    mov rax, 1      ; rax: syscall number 1
    mov rdi, 1      ; rdi: fd 1 for stdout
    mov rsi,message ; rsi: pointer to message
    mov rdx, 20     ; rdx: print length of 20 bytes
    syscall         ; call write syscall to the intro message
    ret

initFib:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    ret

loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
    ret

Exit:
    mov rax, 60
    mov rdi, 0
    syscall

```

Now, the **main execution flow** is clear:

1.  `_start` calls each procedure in order.
    
2.  Each procedure performs its task, then returns.
    
3.  The program exits cleanly.
    

Notice that `Exit` does **not** use `ret` — because we don’t want to return anywhere; we want to terminate the program.

* * *

### Notes on Execution Flow

Assembly executes code **linearly** unless instructed otherwise.

- Without a `ret`, execution simply continues into the next label.
    
- With a `ret`, control returns to the caller (where `call` was made).
    

So, always remember:

- Use `ret` in every procedure except the one that ends the program.
    
- The stack keeps track of where to return.
    

* * *

### Bonus: `enter` and `leave`

In more advanced assembly programs, you might see `enter` and `leave` instructions.  
They are used to:

- Save the current stack frame.
    
- Allocate local stack space for the procedure.
    
- Restore the previous stack frame before returning.
    

They’re common in functions that handle local variables or nested calls, but not needed in our simple example.

* * *

### Summary

| Concept | Purpose |
| --- | --- |
| **Procedure** | Reusable block of instructions labeled for specific tasks. |
| **CALL** | Saves the return address and jumps to a procedure. |
| **RET** | Returns to the saved address after procedure execution. |
| **ENTER/LEAVE** | Manage stack frames for complex procedures (optional). |

By refactoring your assembly code into procedures, you gain:

- Reusability
    
- Clarity
    
- Easier debugging and maintenance
    

* * *

&nbsp;