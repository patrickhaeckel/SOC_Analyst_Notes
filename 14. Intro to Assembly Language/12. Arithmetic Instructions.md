---
title: 12. Arithmetic Instructions
updated: 2025-10-10 23:45:26Z
created: 2025-10-10 03:19:13Z
---

# Arithmetic and Bitwise Instructions in Assembly

In assembly, **arithmetic and bitwise instructions** let us perform math and logic directly on CPU registers or memory.  
These operations are handled by the **ALU (Arithmetic Logic Unit)** — the part of the CPU responsible for performing calculations.

We’ll look at them in three groups:

1.  **Unary instructions** – operate on one operand.
    
2.  **Binary instructions** – operate on two operands.
    
3.  **Bitwise instructions** – work on individual bits within values.
    

* * *

## 1\. Unary Arithmetic Instructions

Unary means **one operand** — the instruction affects a single register or memory location.

| Instruction | Description | Example | Effect (if `rax = 1`) |
| --- | --- | --- | --- |
| `inc` | Increment by 1 | `inc rax` | `rax = 2` |
| `dec` | Decrement by 1 | `dec rax` | `rax = 0` |

Both `inc` and `dec` are shorthand for adding or subtracting 1.

* * *

### Example: Using `inc`

```
global  _start
section .text
_start:
    mov al, 0     ; set AL = 0
    mov bl, 0     ; set BL = 0
    inc bl        ; increase BL by 1 → BL = 1

```

When run under a debugger:

- Before `inc`: `rbx = 0x0`
    
- After `inc`: `rbx = 0x1`
    

So, `inc` increased the register’s value by 1.  
`dec` does the opposite — subtracts 1 instead.

These are commonly used in loops or counters.

* * *

## 2\. Binary Arithmetic Instructions

Binary means **two operands** — typically a destination and a source.  
The **result is stored in the destination**, while the source remains unchanged.

| Instruction | Description | Example | Result (if `rax = 1`, `rbx = 1`) |
| --- | --- | --- | --- |
| `add` | Add both operands | `add rax, rbx` | `rax = 1 + 1 → 2` |
| `sub` | Subtract source from destination | `sub rax, rbx` | `rax = 1 - 1 → 0` |
| `imul` | Multiply both operands (signed multiply) | `imul rax, rbx` | `rax = 1 * 1 → 1` |

* * *

### Example: Fibonacci Addition

Adding two numbers is the core operation of Fibonacci’s formula:  
**Fn = Fn-1 + Fn-2**

```
global  _start
section .text
_start:
    mov al, 0     ; AL = 0
    mov bl, 0     ; BL = 0
    inc bl        ; BL = 1
    add rax, rbx  ; RAX = 0 + 1 → 1

```

After `add`, RAX holds the sum of RAX and RBX.

You can similarly test `sub` or `imul` by replacing `add` with those instructions and observing the changes in registers.

* * *

## 3\. Bitwise Instructions

Bitwise operations work at the **bit level** — they manipulate each individual bit in a register.  
Let’s assume:

`RAX = 00000001 (1)`

`RBX = 00000010 (2)`

| Instruction | Description | Example | Result (binary → decimal) |
| --- | --- | --- | --- |
| `not` | Invert all bits | `not rax` | `11111110` → 254 |
| `and` | Logical AND (1 only if both bits are 1) | `and rax, rbx` | `00000000` → 0 |
| `or` | Logical OR (1 if either bit is 1) | `or rax, rbx` | `00000011` → 3 |
| `xor` | Logical XOR (1 if bits differ) | `xor rax, rbx` | `00000011` → 3 |

* * *

### Understanding `xor rax, rax`

The **XOR** instruction is extremely useful in assembly — especially for clearing registers.

`xor rax, rax`

Means:

- Compare each bit of `rax` with itself.
    
- Since all bits are equal, the result is all zeros.
    

So it’s the fastest way to set a register to zero — even faster than `mov rax, 0`.

* * *

### Example: Using `xor` in Fibonacci Setup

Instead of using `mov` to clear registers:

```
global  _start
section .text
_start:
    xor rax, rax   ; rax = 0
    xor rbx, rbx   ; rbx = 0
    inc rbx        ; rbx = 1
    add rax, rbx   ; rax = 0 + 1 → 1

```

This performs the same logic as before but is **more efficient** and **more idiomatic** in assembly.

* * *

## Arithmetic vs Bitwise

| Category | Operates On | Examples | Notes |
| --- | --- | --- | --- |
| **Unary** | 1 operand | `inc`, `dec` | Modify one value directly |
| **Binary** | 2 operands | `add`, `sub`, `imul` | Combine two values; result in destination |
| **Bitwise** | 1–2 operands | `not`, `and`, `or`, `xor` | Manipulate bits; used in logic and optimization |

* * *

### Key

- **Unary** = one target (increment/decrement)
    
- **Binary** = two targets (add, subtract, multiply)
    
- **Bitwise** = operates per bit (logic-level operations)
    
- **`xor reg, reg`** is the fastest zeroing method in assembly.
    
- The **ALU** executes all these arithmetic and logical operations internally.
    

&nbsp;