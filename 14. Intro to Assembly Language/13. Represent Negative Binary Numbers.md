---
title: 13. Represent Negative Binary Numbers
updated: 2025-10-28 04:25:51Z
created: 2025-10-10 23:45:40Z
---

# Signed and Unsigned Binary Numbers

## 1\. What Binary and Hexadecimal Are

- **Binary** uses only `0` and `1`.
    
- Each binary digit (bit) represents a power of 2:
    
- ```
    128  64 32 16 8 4 2 1  0
     ↑   ↑  ↑  ↑  ↑  ↑  ↑  ↑
     b7  b6 b5 b4 b3 b2 b1 b0
    
    ```
    
- **Hexadecimal (base 16)** is shorthand for binary:
    

`1 hex digit = 4 binary bits`

Example:

- `0xA3 = 1010 0011 (binary)`

* * *

## 2\. Unsigned Numbers (All Positive)

Unsigned means **no negative values** — every bit contributes to the magnitude.

### Example (8 bits)

```
Binary: 01101101
= 64 + 32 + 8 + 4 + 1 = 109

```

Unsigned value = **109**

**Range for unsigned values:**

| Bit width | Range |
| --- | --- |
| 8 bits | 0 → 255 |
| 16 bits | 0 → 65,535 |
| 32 bits | 0 → 4,294,967,295 |

* * *

## 3\. Signed Numbers: Introducing Two’s Complement

Unsigned numbers can’t represent negatives, so computers use **two’s complement** to represent both positive and negative values with the same bit patterns.

### Key Rule

- The **most significant bit (MSB)** = sign bit:
    
    - `0` → positive
        
    - `1` → negative
        

### Two’s complement range:

| Bits | Range |
| --- | --- |
| 8 bits | –128 → +127 |
| 9 bits | –256 → +255 |
| 10 bits | –512 → +511 |
| 16 bits | –32,768 → +32,767 |

* * *

## 4\. How Two’s Complement Works

When MSB = 1, it means the number is negative.  
To find its decimal value:

Signed Value={Unsigned Value,if MSB = 0    Unsigned Value−2n, if MSB = 1    

Where n = number of bits.

* * *

### Example: 8-bit binary `11111111`

Unsigned = 255  
Signed = 255 – 256 = **–1**

* * *

### Example Table

| Binary | Hex | Unsigned | Signed | Explanation |
| --- | --- | --- | --- | --- |
| 01111111 | 7F  | 127 | +127 | MSB=0 (positive) |
| 10000000 | 80  | 128 | –128 | MSB=1 → 128–256 |
| 10000001 | 81  | 129 | –127 | 129–256 |
| 11111111 | FF  | 255 | –1  | 255–256 |
| 00000000 | 00  | 0   | 0   | all zeros |

* * *

## 5\. Why Subtract 2n2n?

Because binary “wraps around.”  
After the maximum positive value, the next binary pattern loops back into the negatives.

Example with 8 bits:

```
Unsigned counting:
... 126, 127, 128, 129, ..., 255

```

Two’s complement interpretation:

```
... +126, +127, –128, –127, ..., –1

```

Subtracting 2^n shifts those “top half” numbers into the negative range.

* * *

## 6\. Creating a Negative Number: “Invert and Add 1”

To create a negative value manually:

1.  Write the positive number in binary.
    
2.  **Invert** all bits (0 → 1, 1 → 0).
    
3.  **Add 1.**
    

* * *

### Example: –10

1.  +10 = `00001010`
    
2.  Invert → `11110101`
    
3.  Add 1 → `11110110`
    

**–10 = 11110110 (binary)**  
**0xF6 (hex)**  
Unsigned = 246, Signed = –10

* * *

### Example: –64

1.  +64 = `01000000`
    
2.  Invert → `10111111`
    
3.  Add 1 → `11000000`
    

**–64 = 11000000 = 0xC0**

* * *

## 7\. When to Invert + Add 1

| Task | Invert + Add 1? | Explanation |
| --- | --- | --- |
| Creating a negative number | Yes | To encode it |
| Finding magnitude of a negative | Yes | To decode it |
| Just interpreting bits | No  | Just apply the sign formula |
| Doing math (CPU operations) | No  | CPU handles it |

* * *

## 8\. Special Cases

### (a) Zero

`00000000` = 0  
No +0 or –0 duplicates — a benefit of two’s complement.

### (b) Minimum negative (–128 in 8 bits)

`10000000` = –128  
This one is **special**:  
You **don’t** invert + add 1 because there is no +128 in 8 bits.  
It’s the edge of the representable range.

| Bit width | Minimum | Binary form |
| --- | --- | --- |
| 8 bits | –128 | `10000000` |
| 9 bits | –256 | `100000000` |
| 10 bits | –512 | `1000000000` |
| 16 bits | –32,768 | `1000000000000000` |

* * *

## 9\. Larger Bit Width Examples

### (a) –192 (16-bit)

1.  +192 = `00000000 11000000`
    
2.  Invert → `11111111 00111111`
    
3.  Add 1 → `11111111 01000000`  
    **Binary = 11111111 01000000**  
    **Hex = 0xFF40**  
    Signed = –192
    

* * *

### (b) –256

- Needs **≥9 bits**, since 8-bit range stops at –128.
    
- In 16 bits:
    
- `11111111 00000000`
    
    Hex = 0xFF00  
    Signed = –256
    

* * *

### (c) –512

- Needs **≥10 bits**
    
- Binary = `1000000000`  
    (MSB alone is 1 → lowest value)
    
- Unsigned = 512
    
- Signed = 512 – 1024 = **–512**
    

* * *

## 10\. Pattern Summary

| Bit width | Lowest value | Binary pattern |
| --- | --- | --- |
| 8 bits | –128 | `10000000` |
| 9 bits | –256 | `100000000` |
| 10 bits | –512 | `1000000000` |
| 16 bits | –32,768 | `1000000000000000` |

Whenever **only the MSB is 1**, that’s the **most negative value** for that bit width.

* * *

## 11\. Visual Concept: Binary “Number Wheel”

Imagine counting on a circular dial (like a clock):

```
Unsigned: 0 → 127 → 128 → 255 → back to 0
Signed:   0 → 127 → -128 → -1 → back to 0

```

After `01111111` (+127), one more increment wraps around to `10000000` (–128).

That’s how binary addition/subtraction naturally wraps across zero —  
**no special circuits needed!**

* * *

## 12\. Why Two’s Complement is Brilliant

| Feature | Why it matters |
| --- | --- |
| Only one zero | No +0/–0 confusion |
| Easy math | Addition/subtraction use the same hardware for signed and unsigned |
| Wrap-around logic | Overflow naturally loops in both directions |
| Simple range check | MSB instantly shows the sign |

* * *

## TL;DR Recap

| Concept | Rule | Example |
| --- | --- | --- |
| MSB = 0 | Positive | `01111111` → +127 |
| MSB = 1 | Negative | `11111111` → –1 |
| Create negative | Invert + Add 1 | 10 → –10 → `11110110` |
| Convert back to positive | Invert + Add 1 again | `11110110` → `00001010` |
| Formula | Signed = Unsigned – 2ⁿ | 255 – 256 = –1 |
| Edge value | MSB only = lowest | `10000000` = –128 (8-bit) |

* * *

## 13\. Practice Quick Reference

| Decimal | 8-bit Binary | Hex | Unsigned | Signed |
| --- | --- | --- | --- | --- |
| +10 | `00001010` | `0A` | 10  | +10 |
| –10 | `11110110` | `F6` | 246 | –10 |
| –64 | `11000000` | `C0` | 192 | –64 |
| –125 | `10000011` | `83` | 131 | –125 |
| –128 | `10000000` | `80` | 128 | –128 |
| –192 (16-bit) | `11111111 01000000` | `FF40` | 65344 | –192 |
| –256 (16-bit) | `11111111 00000000` | `FF00` | 65280 | –256 |
| –512 (10-bit) | `1000000000` | `0x200` | 512 | –512 |

* * *

&nbsp;