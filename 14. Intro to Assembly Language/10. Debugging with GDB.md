---
title: 10. Debugging with GDB
updated: 2025-10-11 02:24:00Z
created: 2025-10-08 17:22:34Z
---

# [](https://chatgpt.com/c/68e74f9a-84fc-832e-bedc-87ce4a13b202#main)Debugging with GDB

Here’s a tightened, reorganized explanation that keeps the same ideas but is easier to follow and use during a live debugging session.

## 1) The four debugging actions (quick map)

1.  **Break** — stop execution where you care (set breakpoints).
    
2.  **Examine** — inspect registers, memory, instructions, stack, strings.
    
3.  **Step** — advance execution one instruction/line or until the next source line.
    
4.  **Modify** — change memory or register values and observe effects.
    

You’ll repeat these: set a breakpoint, run to it, inspect state, step through, change values, repeat.

* * *

## 2) Break — stopping the program

- Use `break` or `b` to set breakpoints:
    
    - By function name: `b _start`
        
    - At an absolute instruction address: `b *0x40100a`
        
    - At an offset: `b *_start+10`
        
- If the process is already running, use `continue` (`c`) to reach a newly set breakpoint; `run` (`r`) restarts from program start.
    
- List and manage breakpoints:
    
    - `info breakpoints` — show breakpoints and their state.
        
    - `disable <n>`, `enable <n>`, `delete <n>` — manage them.
        
- Conditional breakpoint:
    
    - `b some_function if i == 3` — stops only when condition holds.

Tip: breakpoints let you focus on the exact place you want to inspect without recompiling.

* * *

## 3) Examine — view registers, memory, strings, and instructions

&nbsp;

To manually examine any of the addresses or registers or examine any other, we can use the `x` command in the format of `x/FMT ADDRESS`, as `help x` would tell us. The `ADDRESS` is the address or register we want to examine, while `FMT` is the examine format. The examine format `FMT` can have three parts:

| Argument | Description | Example |
| --- | --- | --- |
| `Count` | The number of times we want to repeat the examine | `2`, `3`, `10` |
| `Format` | The format we want the result to be represented in | `x(hex)`, `s(string)`, `i(instruction)` |
| `Size` | The size of memory we want to examine | `b(byte)`, `h(halfword)`, `w(word)`, `g(giant, 8 bytes)` |

- Useful GEF commands: `registers` (or `info registers`) shows register values; GEF often prints helpful context automatically when a breakpoint hits.
    
- The GDB `x` command inspects memory: `x/FMT ADDRESS`
    
    - `FMT` = `[count][format][size]`
        
        - count: number of items (default 1)
            
        - format: `x` hex, `s` string, `i` instruction, `d` decimal, etc.
            
        - size: `b` byte, `h` half (2), `w` word (4), `g` giant (8)
            
    - Examples:
        
        - `x/4ig $rip` — show 4 instructions at `$rip` (format=i, size=g).
            
        - `x/s 0x402000` — print a C-style string at address `0x402000`.
            
        - `x/wx 0x401000` — show a 4-byte hex word at `0x401000`.
            
- Inspecting disassembly and the instruction pointer:
    
    - `$rip` contains the next instruction address; the `->` indicator shows the current instruction.
- Inspect stack/heap: use `x/` with addresses near `$rsp` or heap pointers.
    

Example flow (runs to `_start` breakpoint, shows registers, code and stack via GEF):

- `b _start`
    
- `r`
    
- `registers`
    
- `x/4ig $rip`
    
- `x/s 0x402000`
    

* * *

## 4) Step — move forward in small increments

Three categories:

1.  `si` / `stepi` — step one machine instruction (lowest level).
    
    - `si 3` executes three instructions.
2.  `ni` / `nexti` — step one instruction but step over calls (execute the call as one unit).
    
3.  `s` / `step` — step to the next source line or into called functions (higher-level; will stop at function entry).
    
4.  `n` / `next` — step to the next source line but step *over* function calls.
    

Behavior examples:

- At `_start` you might `si` to watch registers update per-instruction.
    
- Use `s` to enter functions so you can debug inside them.
    
- Use `n` to skip into a long library function you don’t need to inspect.
    

Shortcut: press Enter to repeat the last command (handy to continue stepping the same amount).

* * *

## 5) Modify — change memory or registers on the fly

- Two common ways:
    
    - `set $reg = value` — change a register (e.g., `set $rdx = 0x9`).
        
    - GEF `patch` — write bytes/strings to memory easily.
        
        - `patch string 0x402000 "Patched!\\x0a"` — write a new NUL-terminated string (note the doubled backslash for escaping inside GDB).
            
        - `patch byte 0x401000 0xcc` — write bytes at an address.
            
- Practical example:
    
    1.  Break at write syscall address: `b *0x401019`
        
    2.  `r`
        
    3.  `patch string 0x402000 "Patched!\\x0a"`
        
    4.  If original `write` length was 0x12 (18) and new string length is 9, update the register that holds length: `set $rdx = 0x9`
        
    5.  `c` to continue — observe new output.
        

Important note: if you overwrite a shorter string into longer old storage without updating the length parameter used by `write`, leftover characters remain. Always consider both the buffer and the length argument.

* * *

## 6) Quick command cheat-sheet

- Break: `b <func>`, `b *0xADDR`
    
- Run: `r`
    
- Continue: `c`
    
- Info: `info breakpoints`, `registers`
    
- Examine memory: `x/[count][format][size] ADDRESS` (e.g., `x/s 0x402000`, `x/4ig $rip`)
    
- Step: `si`, `si N`, `ni`, `s`, `n`
    
- Modify register: `set $rax = 0x1`
    
- Patch memory (GEF): `patch string 0xADDR "text"`; `patch byte 0xADDR 0xff`
    

* * *

## 7) Practical debugging workflow example (helloWorld)

1.  `b _start`
    
2.  `r` — program stops at `_start`.
    
3.  `x/4ig $rip` — see the next 4 instructions.
    
4.  `x/s 0x402000` — inspect the message string moved into `rsi`.
    
5.  `si` repeatedly or `si 3` to step to the `syscall` that writes the string.
    
6.  If you want to change output: `patch string 0x402000 "Patched!\\x0a"` then `set $rdx = 0x9` and `c`.
    

* * *

## 8) Tips and pitfalls

- `run` restarts the program; use `continue` to move forward from the current state.
    
- When patching strings, remember NUL-termination and leftover bytes from previous content.
    
- Conditional breakpoints are essential to avoid stopping on every loop iteration.
    
- Use `ni` / `nexti` to skip over called functions when stepping through instructions.
    
- GEF and similar plugins provide useful visuals (register highlighting, stack, code) — but all actions above work with vanilla GDB.
    

* * *

## 9) Why this matters for reverse engineering & exploitation

- Stop where parsing or I/O happens, inspect buffers and lengths, change inputs or lengths live, and observe control-flow — this is how you confirm vulnerability conditions without editing or recompiling code.
    
- Being able to patch memory and registers lets you simulate exploit primitives and validate exploit ideas fast.
    

* * *

&nbsp;