---
title: '21. Libc '
updated: 2025-10-14 01:01:18Z
created: 2025-10-14 00:57:08Z
---

## Overview

This tutorial shows how to make a Fibonacci number program **dynamic** (accepting user input) instead of **static** (always printing the same output). It does this by using the `scanf` function from the C standard library (libc).

## The Problem

Previously, the program hardcoded `cmp rbx, 10` to only print Fibonacci numbers less than 10. Now we want the user to choose the maximum number.

## Function Calling Convention (The Rules)

When calling external functions in assembly, you must follow these steps:

1.  **Save registers** - Preserve any values you need later
2.  **Pass arguments** - Put function parameters in specific registers
3.  **Align the stack** - Make sure the stack pointer is at a 16-byte boundary
4.  **Call the function** - Execute it
5.  **Get return value** - Retrieved from the `rax` register

## Step-by-Step Implementation

### 1\. Import the Function

```nasm
extern printf, scanf
```

This tells the assembler you'll be using external functions from libc.

### 2\. Create a Buffer for Input

```nasm
section .bss
    userInput resb 1    ; Reserve 1 byte for storing user input
```

The `.bss` section is for **uninitialized data** - space you reserve but don't set to any value yet.

### 3\. Set Up Format Strings

```nasm
section .data
    inFormat db "%d", 0x00    ; Format for scanf (read integer)
```

The `%d` tells `scanf` to expect a decimal integer.

### 4\. The getInput Procedure

```nasm
getInput:
    sub rsp, 8          ; Fix stack alignment (explained below)
    mov rdi, inFormat   ; 1st argument: format string
    mov rsi, userInput  ; 2nd argument: where to store input
    call scanf          ; Call the function
    add rsp, 8          ; Restore stack
    ret
```

**Why `sub rsp, 8`?**

The stack must be aligned to 16-byte boundaries. When you `call` a procedure, it pushes an 8-byte return address. So:

- Before `call getInput`: stack is aligned (16-byte boundary)
- After `call getInput`: stack is +8 bytes (misaligned)
- After `sub rsp, 8`: stack is +16 bytes (aligned again!)

### 5\. Use the Input

Instead of:

```nasm
cmp rbx, 10    ; Compare with hardcoded 10
```

We now use:

```nasm
cmp rbx, [userInput]    ; Compare with user's input
```

**Why `[userInput]` with brackets?**

- `userInput` = the **memory address** where the value is stored
- `[userInput]` = the **actual value** at that address

It's like the difference between a house address and the person living inside.

### 6\. Linking with Dynamic Linker

bash

```bash
ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2
```

This links your assembly code with the C library and specifies the **dynamic linker** that loads shared libraries at runtime.

## Complete Flow

1.  Program starts
2.  Prints "Please input max Fn"
3.  Calls `getInput` → `scanf` waits for user to type a number
4.  Number is stored in `userInput`
5.  Fibonacci loop compares each number with `[userInput]`
6.  Stops when Fibonacci number exceeds user's input

## Key Concepts

- **`.bss` section**: For uninitialized variables (buffers)
- **Stack alignment**: Must be 16-byte aligned before function calls
- **`[address]` syntax**: Dereferences a pointer to get the actual value
- **External functions**: Require proper linking with `-lc` flag

&nbsp;

## Complete Code Breakdown

### **1\. printMessage Procedure**

nasm

```nasm
printMessage:
    push rbp            ; Save base pointer
    mov rdi, message    ; 1st arg: pointer to "Please input max Fn\n"
    xor rax, rax        ; No floating-point args for printf
    call printf
    pop rbp             ; Restore base pointer
    ret
```

- Prints the prompt asking for user input
- `xor rax, rax` sets rax to 0 (printf needs this for variable args)

### **2\. getInput Procedure**

nasm

```nasm
getInput:
    sub rsp, 8          ; Align stack (we have 1 call = 8 bytes, need 16)
    mov rdi, inFormat   ; 1st arg: "%d" format
    mov rsi, userInput  ; 2nd arg: address where input will be stored
    call scanf
    add rsp, 8          ; Restore original stack position
    ret
```

- Reads an integer from the user
- Stores it in the `userInput` buffer

### **3\. initFib Procedure**

nasm

```nasm
initFib:
    xor rax, rax        ; rax = 0 (F0)
    xor rbx, rbx        ; rbx = 0
    inc rbx             ; rbx = 1 (F1)
    ret
```

- Sets up the first two Fibonacci numbers: 0 and 1
- `rax` holds F(n-1), `rbx` holds F(n)

### **4\. printFib Procedure**

nasm

```nasm
printFib:
    push rax            ; Save current values
    push rbx
    
    mov rdi, outFormat  ; 1st arg: "%d\n" format
    mov rsi, rbx        ; 2nd arg: the number to print
    xor rax, rax        ; Clear rax for printf
    call printf
    
    pop rbx             ; Restore values
    pop rax
    ret
```

- Prints the current Fibonacci number stored in `rbx`
- Saves/restores registers so the calculation isn't affected

### **5\. loopFib Procedure**

nasm

```nasm
loopFib:
    call printFib       ; Print current number
    
    add rax, rbx        ; Calculate next: rax = rax + rbx
    xchg rax, rbx       ; Swap: now rbx has new value, rax has old rbx
    
    cmp rbx, [userInput]; Is current Fib < user's max?
    js loopFib          ; If yes (negative result), loop again
    ret
```

- **The Fibonacci magic**: `add` calculates the next number, `xchg` shifts values forward
- **Example**: If rax=1, rbx=1 → after add: rax=2, rbx=1 → after xchg: rax=1, rbx=2

### **6\. Exit Procedure**

nasm

```nasm
Exit:
    mov rax, 60         ; Syscall 60 = exit
    xor rdi, rdi        ; Exit code 0 (success)
    syscall
```

- Cleanly exits the program

## How to Compile and Run

bash

```bash
# Assemble, link, and run

nasm -f elf64 fib.s && ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 && ./fib
```

**What each flag does:**

- `-f elf64`: Create 64-bit ELF object file
- `-lc`: Link with C standard library
- `--dynamic-linker`: Specify the runtime linker for shared libraries

## Example Output

```
Please input max Fn:
100
1
1
2
3
5
8
13
21
34
55
89
```

The program prints all Fibonacci numbers less than 100!

```armasm
global  _start
extern  printf, scanf

section .data
    message db "Please input max Fn", 0x0a
    outFormat db  "%d", 0x0a, 0x00
    inFormat db  "%d", 0x00

section .bss
    userInput resb 1

section .text
_start:
    call printMessage   ; print intro message
    call getInput       ; get max number from user
    call initFib        ; set initial Fibonacci values
    call loopFib        ; calculate Fibonacci numbers
    call Exit           ; Exit the program

printMessage:
    ; Print the intro message
    push rbp
    mov rdi, message
    xor rax, rax
    call printf
    pop rbp
    ret

getInput:
    ; Get user input using scanf
    sub rsp, 8          ; align stack to 16-bytes
    mov rdi, inFormat   ; set 1st parameter (format string: "%d")
    mov rsi, userInput  ; set 2nd parameter (buffer to store input)
    call scanf          ; scanf(inFormat, userInput)
    add rsp, 8          ; restore stack alignment
    ret

initFib:
    ; Initialize first two Fibonacci numbers
    xor rax, rax        ; set rax to 0 (F0 = 0)
    xor rbx, rbx        ; set rbx to 0
    inc rbx             ; increment rbx to 1 (F1 = 1)
    ret

printFib:
    ; Print current Fibonacci number
    push rax            ; save rax (current Fib number)
    push rbx            ; save rbx (next Fib number)
    
    mov rdi, outFormat  ; set 1st parameter (format: "%d\n")
    mov rsi, rbx        ; set 2nd parameter (Fibonacci number to print)
    xor rax, rax        ; clear rax (no floating point args)
    call printf         ; printf(outFormat, rbx)
    
    pop rbx             ; restore rbx
    pop rax             ; restore rax
    ret

loopFib:
    ; Main Fibonacci calculation loop
    call printFib       ; print current Fibonacci number
    
    add rax, rbx        ; get next Fibonacci: F(n+1) = F(n) + F(n-1)
    xchg rax, rbx       ; swap values: rax <-> rbx
    
    cmp rbx, [userInput]; compare current Fib with user's max
    js loopFib          ; jump if result is negative (rbx < userInput)
    ret

Exit:
    ; Exit program cleanly
    mov rax, 60         ; syscall number for exit
    xor rdi, rdi        ; exit code 0
    syscall
```