---
title: 09. GNU Debugger (GDB)
updated: 2025-10-08 17:39:45Z
created: 2025-10-08 02:41:50Z
---

# Debugging with GNU Debugger (GDB)

Now that we can assemble and run binaries, the next step is learning how to inspect and control them as they execute. This process—called **debugging**—lets us pause a program, observe what it’s doing, and identify why it isn’t behaving as expected.

Debugging is an essential skill for both **developers** and **pentesters**. Developers use it to find and fix programming errors, while pentesters use it to understand and manipulate binary behavior during reverse engineering or exploitation.

* * *

## 1\. What Debugging Means

When we “debug” a program, we’re not just changing code randomly and hoping it works.  
Instead, we **run the program under a debugger**, set **breakpoints** at key points in the code, and **inspect memory, registers, and variables** as execution proceeds. This helps us clearly see where things go wrong.

For higher-level languages, debuggers operate on source code lines.  
For Assembly or raw binaries, breakpoints are set on **memory addresses** that correspond to actual machine instructions.

* * *

## 2\. Introducing GDB

The **GNU Debugger (GDB)** is the standard debugger for Linux systems. It lets us:

- Run and pause programs at specific instructions
    
- Examine registers, memory, and variables
    
- Step through code instruction by instruction
    
- Modify values at runtime
    

There are other debuggers—like **Radare**, **Hopper**, **Immunity Debugger** (Windows), and **IDA Pro**—but GDB stands out for its deep integration with Linux and open-source reliability.

* * *

## 3\. Installing GDB

GDB comes preinstalled in most Linux distributions, including **Parrot OS** and **PwnBox**.  
If it isn’t available, install it with:

`sudo apt-get update`

`sudo apt-get install gdb`

* * *

## 4\. Enhancing GDB with GEF

GDB supports plugins to improve usability.  
A popular one is **GEF (GDB Enhanced Features)**—an open-source plugin built specifically for reverse engineering and binary exploitation.

To install GEF:

`wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py`

`echo "source ~/.gdbinit-gef.py" >> ~/.gdbinit`

Once installed, GEF will automatically load every time you start GDB.

* * *

## 5\. Starting a Debugging Session

To begin debugging a binary, simply run:

`gdb -q ./helloWorld`

If GEF is properly installed, the prompt will look like this:

`gef➤`

If you encounter issues, check the GEF documentation

for solutions.

* * *

## 6\. Using GDB with Assembly Code

When working with Assembly, we often need to assemble, link, and immediately debug our program.  
If you’ve already created a helper script like `assembler.sh`, you can automate the process with the `-g` flag:

`./assembler.sh helloWorld.s -g`

This assembles, links, and runs the binary directly under GDB.

* * *

## 7\. Exploring a Binary with `info`

Once GDB is running, the `info` command provides details about the program.

- **Functions**

`info functions`

Lists all defined functions, for example:

- `0x0000000000401000 _start`
    
- **Variables**
    

`info variables`

Displays global or static variables:

- `0x0000000000402000 message`
- `0x0000000000402012 _edata`

Tip: Use `help <command>` to view documentation inside GDB, e.g., `help info`.

* * *

## 8\. Disassembling Functions

To inspect the Assembly instructions of a function, use:

`disas _start`

You’ll see output like:

```
Dump of assembler code for function _start:
   0x0000000000401000 <+0>:	mov    eax,0x1
   0x0000000000401005 <+5>:	mov    edi,0x1
   0x000000000040100a <+10>:	movabs rsi,0x402000
   0x0000000000401014 <+20>:	mov    edx,0x12
   0x0000000000401019 <+25>:	syscall
   0x000000000040101b <+27>:	mov    eax,0x3c
   0x0000000000401020 <+32>:	mov    edi,0x0
   0x0000000000401025 <+37>:	syscall
End of assembler dump.

```

Each instruction includes its **memory address**, **opcode**, and **operands**.  
These addresses are critical when setting breakpoints or examining memory.

* * *

## 9\. Understanding Memory Addresses

You may notice addresses like `0x000000000040xxxx` instead of full raw addresses.  
This is because modern binaries often use **Position-Independent Executables (PIE)**, where memory addresses are calculated **relative to the instruction pointer (`$rip`)**.  
This improves security by making memory layout unpredictable, but it can be disabled during learning or testing if needed.

* * *

&nbsp;

&nbsp;