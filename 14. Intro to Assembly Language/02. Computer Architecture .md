---
title: "02. Computer Architecture\_"
updated: 2025-10-06 23:10:57Z
created: 2025-10-05 18:19:50Z
---

# **Computer Architecture**

Modern computers are based on the **Von Neumann Architecture**, proposed by **John von Neumann** in 1945. This model made it possible to build **General-Purpose Computers**, a concept first described by **Alan Turing**, who himself drew inspiration from **Charles Babbage’s** 19th-century idea of a **programmable machine**. All three were mathematicians, not engineers—highlighting the foundational role of math and logic in computing.

This architecture is centered around executing **machine code**—binary instructions that tell the hardware how to perform algorithms. It consists of the following core components:

- **Central Processing Unit (CPU)**
    
- **Memory Unit**
    
- **Input/Output Devices**, including:
    
    - Mass Storage
        
    - Keyboard
        
    - Display
        

### **CPU Components**

The CPU is further divided into:

- **Control Unit (CU)** – Directs the flow of data and instructions.
    
- **Arithmetic Logic Unit (ALU)** – Performs calculations and logical operations.
    
- **Registers** – Small storage locations inside the CPU for quick access to data.
    

Despite being over 75 years old, the Von Neumann model still forms the basis of all modern CPUs—whether in laptops, servers, or smartphones.

Understanding this structure is **essential for working with Assembly**, since it interacts directly with the CPU and memory. It's also crucial for **binary exploitation**, from basic stack overflows to advanced techniques like ROP (Return-Oriented Programming) and heap exploitation.

* * *

# **Memory**

Memory—also called **Primary Memory**—temporarily stores the instructions and data used by running programs. Since the CPU accesses it **billions of times per second**, it needs to be extremely fast.

There are two main types of memory:

- **Cache** (very fast, small, near the CPU)
    
- **RAM** (larger, slower, used for general storage during execution)
    

* * *

## **Cache**

Located inside or very close to the CPU, **cache memory** is built for **speed**, not size. It bridges the performance gap between the ultra-fast CPU and the slower RAM.

Without cache, the CPU would constantly be **waiting on RAM**, greatly reducing overall speed.

### **Levels of Cache**

| Level | Description |
| --- | --- |
| Level 1 Cache | Usually in kilobytes, the fastest memory available, located in each CPU core. (Only registers are faster.) |
| Level 2 Cache | Usually in megabytes, extremely fast (but slower than L1), shared between all CPU cores. |
| Level 3 Cache | Usually in megabytes (larger than L2), faster than RAM but slower than L1/L2. (Not all CPUs use L3.) |

* * *

## **RAM**

RAM (Random Access Memory) is **much larger than cache**—ranging from **gigabytes to terabytes**—but also **much slower**.

Fetching data from RAM can take **~200 clock cycles**, compared to just **1-3 clock cycles** for Registers or Cache. These delays add up fast when repeated billions of times.

### **Address Space Example**

- **32-bit systems**: Memory addresses range from `0x00000000` to `0xffffffff`, i.e., **4 GB** maximum.
    
- **64-bit systems**: Address range extends to `0xffffffffffffffff`, or **18.5 exabytes** (18.5 million TB).  
    <br/>**This expansion solved the 4 GB RAM limitation seen in 32-bit computers.  
    <br/>**
    

### **Memory Layout**

| Segment | Description |
| --- | --- |
| Stack | LIFO (Last-In, First-Out), fixed in size. Data is accessed in order using push/pop.                                  <----- high address |
| Heap | Hierarchical and flexible, allows random access.  <br>Data can be stored and retrieved in any order. Slower than stack. |
| Data | Holds initialized (`data`) and uninitialized (`.bss`) which is used to hold  <br>unassigned variables (i.e., buffer memory for later allocation).. |
| Text | Main assembly instructions are loaded into this segment to be fetched and executed by the CPU.        <----- low address |

### Each running program is given its **own virtual memory space**—including separate stack, heap, data, and text segments—thanks to memory virtualization.  
<br/>

* * *

# **Input/Output (I/O) and Storage**

**I/O Devices** include:

- **Keyboard**
    
- **Monitor**
    
- **Storage Devices** (Hard Drives, SSDs)
    

These interact with the CPU via **Bus Interfaces**—electrical “highways” that carry binary signals.

- Buses are typically **4 to 128 bits wide**.
    
- They're used not just for I/O, but for communication with **RAM** and other components as well.  
    <br/>**Visual Note**: A close-up of a motherboard or CPU will reveal these intricate bus lines everywhere.
    

* * *

## **Storage Devices**

Unlike volatile RAM, storage (also called **Secondary Memory**) retains data **permanently**, even without power. Examples include:

- **Hard Disk Drives (HDDs)** – Magnetic storage, slower, mechanical.
    
- **Solid-State Drives (SSDs)** – Faster, use non-volatile memory similar to RAM.
    

Despite SSDs being much faster than HDDs, they are still **slower than RAM** due to their distance from the CPU and reliance on interfaces like **SATA** or **USB**.

* * *

# **Component Speed & Size Summary**

| Component | Speed | Size |
| --- | --- | --- |
| Registers | Fastest | Bytes |
| L1 Cache | Fastest, other than Registers | Kilobytes |
| L2 Cache | Very fast | Megabytes |
| L3 Cache | Fast, but slower than the above | Megabytes |
| RAM | Much slower than all of the above | Gigabytes-Terabytes |
| Storage | Slowest | Terabytes and more |

Speed here is **relative** to the CPU’s clock cycles. The **closer** a component is to the CPU and the **smaller** its size, the **faster** it is.

* * *

&nbsp;