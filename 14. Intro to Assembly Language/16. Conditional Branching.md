---
title: 16. Conditional Branching
updated: 2025-10-13 02:24:58Z
created: 2025-10-13 02:20:05Z
---

## **Conditional Branching in Assembly**

Conditional branching allows your program to *make decisions* — to jump to a different part of the code **only when a specific condition is met**.  
This is different from **unconditional branching** (like `jmp`), which always jumps regardless of any conditions.

In x86-64 assembly, conditional jumps are written as **`Jcc`**, where `cc` stands for the **condition code** — a short label describing the condition being tested (e.g. equal, greater, zero, etc.).

* * *

### **Common Conditional Jump Instructions**

| Instruction | Condition | Description |
| --- | --- | --- |
| `jz` | D = 0 | Jump if Zero (ZF = 1) |
| `jnz` | D ≠ 0 | Jump if Not Zero (ZF = 0) |
| `js` | D < 0 | Jump if Negative (SF = 1) |
| `jns` | D ≥ 0 | Jump if Not Negative (SF = 0) |
| `jg` | D > S | Jump if Greater |
| `jge` | D ≥ S | Jump if Greater or Equal |
| `jl` | D < S | Jump if Less |
| `jle` | D ≤ S | Jump if Less or Equal |

There are many other variants; see Intel’s *Jcc – Jump if Condition Is Met* section for a complete list.

* * *

## **Conditional Execution Beyond Jumps**

Conditional branching isn’t limited to jumps.  
You can also make **other instructions conditional**, such as:

- **`CMOVcc` (Conditional Move)** – moves data if a condition is met.  
    Example:
    
- ```
    cmovz rax, rbx    ; Move if Zero, Flag = 1
    cmovl rax, rbx    ; Move if Less (Negative)
    
    ```
    
- **`SETcc` (Conditional Set)** – sets a byte to 1 if condition is true, or 0 otherwise.  
    Example:
    
- ```
    setz al            ; Set AL = 1 if Zero Flag = 1, else AL = 0
    
    ```
    

* * *

## **The RFLAGS Register: How Conditions Are Tracked**

All these conditional instructions depend on **flag bits** stored in the **RFLAGS register** (64-bit).  
Unlike normal registers, RFLAGS doesn’t store general data — instead, it stores status flags that reflect the results of arithmetic or logic operations.

Example:

- After `dec rax`, if the result is `0`, the **Zero Flag (ZF)** becomes `1`.
    
- After `sub`, if the result is negative, the **Sign Flag (SF)** becomes `1`.
    
- After `div`, if there’s a remainder, the **Carry Flag (CF)** might be set.
    

* * *

### **Important Flags in RFLAGS**

| Bit | Flag | Description | When Set |
| --- | --- | --- | --- |
| 0   | CF  | Carry Flag | Arithmetic overflow (borrow or carry) |
| 2   | PF  | Parity Flag | Result has even parity |
| 4   | AF  | Auxiliary Carry | Carry between nibbles (BCD) |
| 6   | ZF  | Zero Flag | Result = 0 |
| 7   | SF  | Sign Flag | Result is negative |
| 10  | DF  | Direction Flag | String direction (inc/dec) |
| 11  | OF  | Overflow Flag | Signed overflow |

The lower 16 bits form the **FLAGS** register (used in 16-bit mode), and the lower 32 bits form **EFLAGS**.

For most purposes, you’ll mainly use **CF**, **ZF**, **SF**, and sometimes **OF**.

* * *

## **Example: Using `jnz` to Create a Loop**

```
global _start

section .text
_start:
    xor rax, rax    ; rax = 0
    xor rbx, rbx    ; rbx = 0
    inc rbx         ; rbx = 1
    mov rcx, 10     ; loop counter = 10

loopFib:
    add rax, rbx    ; Fibonacci calculation
    xchg rax, rbx   ; swap registers
    dec rcx         ; decrease counter
    jnz loopFib     ; jump while rcx ≠ 0

```

Explanation:

1.  Each loop decreases `rcx`.
    
2.  `dec rcx` affects the Zero Flag (ZF).
    
3.  `jnz` checks if ZF = 0 (not zero).
    
    - If true → jump again.
        
    - If false (ZF = 1) → stop looping.
        

When `rcx` reaches 0, ZF = 1 → no jump → loop ends.

* * *

## **Using `cmp` to Compare Values**

`cmp` compares two operands **without modifying them**.  
It performs a subtraction:

```
cmp dest, src   ; dest - src

```

and updates the flags accordingly.

Example:

```
cmp rbx, 10     ; Compare rbx with 10
js  loopFib     ; Jump if result < 0 (i.e., rbx < 10)

```

So:

- When `rbx = 1`, result = -9 → SF = 1 → jump.
    
- When `rbx = 13`, result = +3 → SF = 0 → stop jumping.
    

This lets you loop while `rbx` is less than 10 — **without changing `rbx`** itself.

* * *

### **Why Use `cmp` Instead of `sub`?**

- `sub` changes the register value.
    
- `cmp` just sets the flags (no data change).
    
- This makes `cmp` ideal for conditional testing.
    

* * *

## **Comparing Conditional Loops**

| Method | Example | Behavior | Efficiency |
| --- | --- | --- | --- |
| **`loop`** | `mov rcx,10` → `loop label` | Auto-decrements `rcx`, jumps if not 0 | Simple but limited |
| **`dec/jnz`** | `dec rcx` → `jnz label` | More flexible, manual control | Efficient, versatile |
| **`cmp/js`** | `cmp rbx,10` → `js label` | Compares directly, no counter | More efficient in simple tests |

* * *

## **Aliases**

Some conditional jumps are aliases:

- `je` = `jz` → Jump if Equal / Zero
    
- `jne` = `jnz` → Jump if Not Equal / Not Zero
    
- `jge` = `jnl` → Jump if Greater or Equal
    
- `jl` = Jump if Less
    

These aliases exist to make code more readable, depending on whether you’re thinking in terms of equality or sign.

* * *

### **Summary**

- **Conditional branching** allows decision-making based on results of prior instructions.
    
- **Flags** in the RFLAGS register (like ZF, SF, CF) determine whether conditions are met.
    
- **`jnz`**, **`cmp`**, and related instructions are the backbone of control flow in assembly.
    
- Tools like **GDB** can show you flag states after each operation, which is key to understanding how your program behaves internally.
    

* * *

&nbsp;