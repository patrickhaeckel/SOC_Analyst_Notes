---
title: 15. Unconditional Branching
updated: 2025-10-13 02:19:43Z
created: 2025-10-13 02:17:21Z
---

## Unconditional Branching in Assembly

In assembly programming, **branching instructions** control the flow of execution by **jumping to different parts of the code**.  
So far, we’ve seen loops that repeat a section of code based on a counter (`rcx`).  
Now, let’s look at **branching**, which gives us more direct control over *where* the CPU executes next.

There are two main kinds of branching:

1.  **Unconditional branching** – always jumps, no matter what.
    
2.  **Conditional branching** – jumps only when a specific condition is true.
    

Let’s start with the simplest one: **unconditional branching**.

* * *

### The `jmp` Instruction

The **`jmp` (jump)** instruction tells the CPU to **immediately jump to a specific label or memory address**, and continue execution from there.  
Once the jump occurs, the CPU **does not return automatically** to the previous location unless you explicitly program it to do so (e.g., with a function call).

**Syntax:**

`jmp <label>`

**Example:**

`jmp loopFib`

This will make the program’s execution jump straight to the label `loopFib` and continue from there.

| Instruction | Description | Example |
| --- | --- | --- |
| `jmp` | Jumps to the specified label, address, or location | `jmp loop` |

* * *

### Example: Using `jmp` in the Fibonacci Program

Let’s modify our earlier Fibonacci example to use an **unconditional jump** instead of the loop instruction.

#### Code:

```
global  _start

section .text
_start:
    xor rax, rax    ; rax = 0 (previous)
    xor rbx, rbx    ; rbx = 0
    inc rbx         ; rbx = 1 (current)
    mov rcx, 10     ; initialize counter (not used here)

loopFib:
    add rax, rbx    ; compute next number
    xchg rax, rbx   ; swap values
    jmp loopFib     ; jump unconditionally back to loopFib

```

This time, we replaced:

`loop loopFib`

with:

`jmp loopFib`

* * *

### What Happens in GDB

Let’s observe what happens when this runs in the debugger.

Set a breakpoint at `loopFib`:

- `gef➤ b loopFib`
    
- `gef➤ r`
    

Watch the registers update on each jump:

```
$rax = 0x1
$rbx = 0x1
$rcx = 0xa
$rax = 0x1
$rbx = 0x2
$rcx = 0xa
$rax = 0x2
$rbx = 0x3
$rcx = 0xa
...

```

Notice that the Fibonacci sequence continues to increase correctly — **but** `rcx` stays the same (`0xa`).  
That’s because **`jmp` doesn’t use `rcx` as a counter** — it just keeps jumping forever.

* * *

### The Infinite Loop Problem

Since `jmp` never checks any condition, your program will **never exit** on its own.  
It behaves like this in pseudocode:

`while True: # do stuff`

In GDB, when you let it continue:

`gef➤ c`

the program keeps running endlessly until you manually stop it (e.g., with **Ctrl + C**).  
When interrupted, the registers might look like this:

```
$rax = 0x2e02a93188557fa9
$rbx = 0x903b4b15ce8cedf0
$rcx = 0xa

```

At this point, the Fibonacci numbers have grown extremely large — because the program never stopped.

* * *

### Summary

| Concept | Description |
| --- | --- |
| **Unconditional Jump (`jmp`)** | Always transfers control to the given label, no matter what. |
| **Difference from `loop`** | `jmp` does **not** check or modify `rcx`. `loop` decrements `rcx` and stops when it reaches zero. |
| **Result** | `jmp` creates an infinite loop if no exit condition is provided. |

* * *

### Key Takeaway

- Use **`jmp`** when you need to jump *no matter what*, such as for permanent loops, program restarts, or control transfers.
    
- Don’t use `jmp` for loops that should end automatically — that’s what **`loop`** or **conditional jumps** are for.
    
- To stop an infinite loop created by `jmp`, you must interrupt it manually or add a **condition** (which you’ll learn in **Conditional Branching**).
    

* * *

&nbsp;