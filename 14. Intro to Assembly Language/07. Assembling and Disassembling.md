---
title: 07. Assembling and Disassembling
updated: 2025-10-08 14:36:22Z
created: 2025-10-08 02:32:57Z
---

## Assembling & Disassembling

Now that we understand the structure of an Assembly file, let’s move from *writing* code to actually *building* and *analyzing* it. This involves three main steps:

1.  **Assembling** — converting human-readable Assembly into machine code.
    
2.  **Linking** — connecting that machine code with system libraries to create an executable.
    
3.  **Disassembling** — reversing the process to inspect the resulting binary.
    

* * *

## 1\. Assembling with NASM

We’ll start by creating a simple program called `helloWorld.s`.  
<br/>**Note:** Assembly source files typically use the `.s` or `.asm` extension. We’ll use `.s` in this module.

### Example Code

```
global _start

section .data
    message db "Hello HTB Academy!"
    length equ $-message

section .text
_start:
    mov rax, 1          ; syscall: write
    mov rdi, 1          ; file descriptor: stdout
    mov rsi, message     ; pointer to message
    mov rdx, length      ; message length
    syscall

    mov rax, 60         ; syscall: exit
    mov rdi, 0          ; exit code 0
    syscall

```

Here, `equ` dynamically calculates the message length (`$-message`), so we don’t need to hardcode it.

To assemble the file, use:

`nasm -f elf64 helloWorld.s`

- `-f elf64`: specifies a 64-bit output format (use `-f elf` for 32-bit).
    
- Output: `helloWorld.o` — an **object file**, which contains machine code but is not yet executable.
    

* * *

## 2\. Linking with LD

The object file still lacks references to system libraries and absolute memory addresses. To create a proper executable, we link it:

`ld -o helloWorld helloWorld.o`

- `-o helloWorld`: sets the output filename.
    
- `ld` produces an **ELF** binary (Executable and Linkable Format), which Linux uses for executables and shared objects.
    

> **Note:** For 32-bit binaries, use `ld -m elf_i386`.

Run your new program:

`./helloWorld`

Output:

`Hello HTB Academy!`

* * *

## 3\. Automating the Build with a Bash Script

Since assembling and linking are repetitive, we can automate them with a script:

```
#!/bin/bash

fileName="${1%%.*}"     # remove .s extension

nasm -f elf64 "${fileName}.s"
ld "${fileName}.o" -o "${fileName}"
[ "$2" == "-g" ] && gdb -q "${fileName}" || "./${fileName}"

```

Usage:

`chmod +x assembler.sh`  
`./assembler.sh helloWorld.s`

This script:

- Assembles and links the input file.
    
- Runs it by default.
    
- If `-g` is passed, opens it in `gdb` instead.
    

* * *

## 4\. Disassembling with OBJDUMP

To understand what NASM and LD did behind the scenes, we can disassemble the binary.  
Use `objdump` with the `-d` flag to decode the `.text` (code) section:

`objdump -M intel -d helloWorld`

Output (simplified):

```
0000000000401000 <_start>:
  401000: b8 01 00 00 00     mov eax,0x1
  401005: bf 01 00 00 00     mov edi,0x1
  40100a: 48 be 00 20 40 00  movabs rsi,0x402000
  401014: ba 12 00 00 00     mov edx,0x12
  401019: 0f 05              syscall
  40101b: b8 3c 00 00 00     mov eax,0x3c
  401020: bf 00 00 00 00     mov edi,0x0
  401025: 0f 05              syscall

```

Notice:

- The label `message` was replaced with its memory address `0x402000`.
    
- `length` was replaced with its actual value (`0x12`).
    
- NASM optimized some 64-bit registers to 32-bit sub-registers for efficiency.
    

### To show only the Assembly instructions:

`objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld`

This omits addresses and hex values, showing only readable Assembly.

* * *

## 5\. Inspecting Data Sections

To see stored strings or data variables, inspect the `.data` section:

`objdump -sj .data helloWorld`

Output:

```
Contents of section .data:
 402000 48656c6c 6f204854 42204163 6164656d  Hello HTB Academ
 402010 7921                                 y!

```

This confirms our `message` variable (“Hello HTB Academy!”) exists exactly as expected in the `.data` section.

* * *

## Summary

| Step | Tool | Purpose | Output |
| --- | --- | --- | --- |
| 1   | `nasm` | Assemble Assembly code into object file | `.o` file |
| 2   | `ld` | Link object file into executable | ELF binary |
| 3   | `objdump` | Disassemble or inspect sections | Readable Assembly + data view |

&nbsp;

&nbsp;