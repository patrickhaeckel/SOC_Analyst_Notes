---
title: 05. Registers, Addresses, and Data Types
updated: 2025-10-09 06:32:59Z
created: 2025-10-05 19:29:55Z
---

## Registers, Addresses, and Data Types

Before diving into assembly programming, it’s crucial to understand several core elements: **Registers**, **Memory Addresses**, **Endianness**, and **Data Types**. These concepts form the foundation of how the CPU and memory interact. Understanding them early prevents countless hours of debugging later.

* * *

### 1\. Registers

Registers are tiny, ultra-fast storage locations built directly into the CPU. Every CPU core has its own set of registers, and they’re used to store small amounts of data (usually just a few bytes) for immediate processing.

In x86-64 architecture, there are many registers, but for learning assembly and basic binary exploitation, we focus on two main categories:

| Type | Purpose | Examples |
| --- | --- | --- |
| **Data Registers** | Store instruction or system call arguments. | `rax`, `rbx`, `rcx`, `rdx`, `r8`, `r9`, `r10`, `rdi`, `rsi` |
| **Pointer Registers** | Store addresses of important memory locations. | `rbp`, `rsp`, `rip` |

**Details:**

- **Data Registers:**  
    Used to hold operands and intermediate results during calculations or function calls.
    
    - `rax`: Accumulator register — often stores return values or system call numbers.
        
    - `rdi`, `rsi`: Typically hold the first and second arguments in function calls.
        
    - `r8–r10`: Extra registers used when the main ones are busy.
        
- **Pointer Registers:**
    
    - `rbp`: **Base Pointer** — points to the base of the current stack frame.
        
    - `rsp`: **Stack Pointer** — always points to the top of the stack.
        
    - `rip`: **Instruction Pointer** — holds the address of the next instruction to execute.
        

* * *

### 2\. Sub-Registers

Each 64-bit register can be divided into smaller parts for working with smaller data sizes. You don’t always need all 64 bits — sometimes 8 or 16 is enough.

| Size | Bytes | Naming Convention | Example (using AX family) |
| --- | --- | --- | --- |
| 8-bit | 1 byte | Ends with `l` | `al` |
| 16-bit | 2 bytes | Base name | `ax` |
| 32-bit | 4 bytes | Prefix `e` | `eax` |
| 64-bit | 8 bytes | Prefix `r` | `rax` |

**Example:**  
For the `bx` register family:

- 8-bit → `bl`
    
- 16-bit → `bx`
    
- 32-bit → `ebx`
    
- 64-bit → `rbx`
    

This structure applies to both data and pointer registers.

**Common Sub-registers:**

| Description | 64-bit | 32-bit | 16-bit | 8-bit |
| --- | --- | --- | --- | --- |
| Syscall/Return | `rax` | `eax` | `ax` | `al` |
| Saved | `rbx` | `ebx` | `bx` | `bl` |
| 1st Arg (Dest) | `rdi` | `edi` | `di` | `dil` |
| 2nd Arg (Src) | `rsi` | `esi` | `si` | `sil` |
| 3rd Arg | `rdx` | `edx` | `dx` | `dl` |
| 4th Arg | `rcx` | `ecx` | `cx` | `cl` |
| 5th Arg | `r8` | `r8d` | `r8w` | `r8b` |
| 6th Arg | `r9` | `r9d` | `r9w` | `r9b` |
| Base Stack Ptr | `rbp` | `ebp` | `bp` | `bpl` |
| Stack Ptr (Top) | `rsp` | `esp` | `sp` | `spl` |
| Instruction Ptr | `rip` | `eip` | `ip` | —   |

Other registers like **RFLAGS** handle CPU status flags (e.g., **ZF** – Zero Flag) but aren’t covered here.

* * *

### 3\. Memory Addresses

x86-64 systems use **64-bit addresses**, ranging from `0x0` to `0xffffffffffffffff`. Memory is divided into regions such as:

- **Stack:** Temporary data, function variables.
    
- **Heap:** Dynamically allocated data.
    
- **Code segment:** Instructions.
    
- **Kernel space:** System-level memory.
    

Each region has specific permissions — read, write, or execute.

#### Addressing Modes

These describe **how the CPU finds data**:

| Mode | Description | Example |
| --- | --- | --- |
| Immediate | Value is included directly in the instruction | `add 2` |
| Register | Value stored in a register | `add rax` |
| Direct | Full memory address given | `call 0xffffffffaa8a25ff` |
| Indirect | Instruction points to another memory location | `call [rax]` |
| Stack | Address located at the top of the stack | `add rsp` |

In general, **Immediate addressing is fastest**, while **Stack and Indirect** are slower.

* * *

### 4\. Address Endianness

**Endianness** defines how bytes are ordered in memory:

| Type | Byte Order | Description |
| --- | --- | --- |
| **Little-Endian** | Right-to-left | Least significant byte stored first |
| **Big-Endian** | Left-to-right | Most significant byte stored first |

**Example:**

For address `0x0011223344556677`:

| Endianness | Memory Order | Stored As |
| --- | --- | --- |
| Little-Endian | Right-to-left | `77 66 55 44 33 22 11 00` |
| Big-Endian | Left-to-right | `00 11 22 33 44 55 66 77` |

Most Intel and AMD CPUs use **Little-Endian**.  
So, when you push data to memory (e.g., a string like “Hello”), it’s stored **in reverse order**: `o`, `l`, `l`, `e`, `H`.

This reversed storage improves efficiency for arithmetic operations and sub-register access.

* * *

### 5\. Data Types

Assembly instructions operate on specific **data sizes**, called **data types**:

| Type | Bits | Bytes | Example |
| --- | --- | --- | --- |
| byte | 8   | 1   | `0xab` |
| word | 16  | 2   | `0xabcd` |
| double word (dword) | 32  | 4   | `0xabcdef12` |
| quad word (qword) | 64  | 8   | `0xabcdef1234567890` |

Operands must match in size. For instance, if using a `byte` variable, pair it with the 8-bit register `al`—not the 64-bit `rax`.

| Register | Data Type |
| --- | --- |
| `al` | byte |
| `ax` | word |
| `eax` | dword |
| `rax` | qword |

* * *

### Summary

- **Registers** hold small, fast-access data.
    
- **Sub-registers** let you use smaller parts of larger registers.
    
- **Addresses** reference memory locations via different addressing modes.
    
- **Endianness** determines how bytes are ordered in memory.
    
- **Data types** define operand sizes for instructions.
    

&nbsp;

&nbsp;