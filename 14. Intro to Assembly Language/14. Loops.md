---
title: 14. Loops
updated: 2025-10-13 02:15:56Z
created: 2025-10-11 00:40:06Z
---

## Loops in Assembly

Now that we’ve covered basic instructions, let’s move into **program control instructions**—commands that allow us to alter the normal sequential flow of execution.  
Normally, assembly instructions are executed **line by line**, one after another. However, most real-world programs need to **repeat** certain actions or **branch** to different parts of the code.  
This is where **control instructions** come in. These include:

- **Loops** – repeat a block of code multiple times
    
- **Branching** – make decisions and jump to specific code sections
    
- **Function calls** – transfer control to reusable subroutines
    

* * *

## Understanding Loop Structures

A **loop** in assembly is simply a set of instructions that executes repeatedly—usually controlled by the **`rcx`** register, which acts as a **loop counter**.

### Basic Loop Example

```
exampleLoop:
    instruction 1
    instruction 2
    instruction 3
    instruction 4
    instruction 5
    loop exampleLoop

```

Here’s how it works:

1.  The **label** `exampleLoop` marks the start of the loop.
    
2.  The **`loop`** instruction automatically:
    
    - Decreases (`dec`) the **`rcx`** register by 1.
        
    - Checks whether **`rcx`** is zero.
        
    - If not zero, it **jumps** back to the label (`exampleLoop`), repeating the loop.
        
3.  When **`rcx`** reaches zero, the loop ends, and execution continues with the next instruction.
    

So before entering a loop, you must **initialize `rcx`** with the desired number of iterations:

`mov rcx, 3 ; loop will run 3 times`

| Instruction | Description | Example |
| --- | --- | --- |
| `mov rcx, x` | Sets loop counter to `x` | `mov rcx, 3` |
| `loop label` | Decrements `rcx` and jumps to `label` while `rcx ≠ 0` | `loop exampleLoop` |

* * *

## Example: Fibonacci Sequence Using Loops

Let’s use a loop to generate the **Fibonacci sequence**, where each number is the sum of the two previous numbers:

`0, 1, 1, 2, 3, 5, 8, 13, ...`

We’ll use:

- `rax` → current number (**Fn**)
    
- `rbx` → next number (**Fn+1**)
    

### Step-by-step logic

1.  Initialize:
    
    - `rax = 0` (previous number)
        
    - `rbx = 1` (current number)
        
    - `rcx = 10` (loop iterations)
        
2.  Inside the loop:
    
    - `add rax, rbx` → compute next number (`Fn + Fn+1`)
        
    - `xchg rax, rbx` → swap values so `rbx` always holds the latest number
        

### Implementation

```
global  _start

section .text
_start:
    xor rax, rax    ; rax = 0 (previous)
    xor rbx, rbx    ; rbx = 0
    inc rbx         ; rbx = 1 (current)
    mov rcx, 10     ; number of iterations

loopFib:
    add rax, rbx    ; next = previous + current
    xchg rax, rbx   ; swap values
    loop loopFib    ; decrement rcx and repeat

```

* * *

## Walking Through Execution with GDB

Let’s debug to see the registers’ behavior step by step.

At the **start**:

```
rax = 0
rbx = 1
rcx = 10

```

After first loop iteration:

```
rax = 1
rbx = 1
rcx = 9

```

After next iterations:

```
rax = 1  rbx = 2  rcx = 8
rax = 2  rbx = 3  rcx = 7
rax = 3  rbx = 5  rcx = 6
rax = 5  rbx = 8  rcx = 5

```

Each iteration computes the next Fibonacci number, storing it in `rbx`.

At the final iteration:

```
rax = 0x22
rbx = 0x37  ; 55 in decimal

```

Confirming in GDB:

```
gef➤  p/d $rbx
$3 = 55

```

* * *

## Summary

- **`rcx`** controls how many times a loop runs.
    
- **`loop label`** automatically decrements `rcx` and jumps back to `label` until it’s zero.
    
- By combining simple operations (`add`, `xchg`, etc.), you can perform iterative computations like Fibonacci in assembly.
    

Try increasing `rcx` to generate more numbers in the sequence!

&nbsp;