---
title: 17. Using the Stack
updated: 2025-10-13 03:18:43Z
created: 2025-10-13 03:16:36Z
---

## Understanding the Stack in Assembly

Before diving into **functions**, we need to understand how the **stack** works — because it plays a crucial role in managing data, preserving register values, and passing parameters.

### 1\. Memory Segments Recap

When a program runs, it’s loaded into **virtual memory**, which is divided into logical segments:

| Segment | Purpose |
| --- | --- |
| **Text segment** | Contains the program’s machine code (instructions executed by the CPU). |
| **Data segment** | Holds global/static variables and constants. |
| **Stack segment** | Used for temporary data storage (function calls, local variables, saved registers, etc.). |

The **stack** grows *downward* in memory — meaning each new value is stored at a lower memory address than the previous one.

* * *

### 2\. Stack Basics

The stack is a special memory region managed by two registers:

| Register | Purpose |
| --- | --- |
| **RSP (Stack Pointer)** | Points to the current **top** of the stack. |
| **RBP (Base Pointer)** | Marks the **bottom** (base) of the current stack frame. |

The stack operates on a **LIFO** principle — *Last In, First Out*.  
This means the last value pushed is the first one that will be popped.

* * *

### 3\. Stack Instructions

| Instruction | Description | Example |
| --- | --- | --- |
| `push <reg>` | Copies the register’s value to the top of the stack. Decreases RSP by 8 bytes. | `push rax` |
| `pop <reg>` | Removes the top value from the stack and places it into the specified register. Increases RSP by 8 bytes. | `pop rbx` |

**Visual Example:**

```
Before push rax
  [RSP] → 0x0000000000000000
rax = 0x1234

After push rax
  [RSP] → 0x0000000000001234

```

Each `push` decreases RSP (stack grows downward).  
Each `pop` increases RSP (stack shrinks upward).

* * *

### 4\. Using the Stack in Practice

When calling **functions** or **system calls**, the CPU often overwrites registers to handle arguments or return values.  
To **preserve** important data, we temporarily store registers on the stack:

#### Example

Suppose we’re about to call a syscall but want to keep the current value of `rax`:

```
push rax     ; Save rax before syscall
mov rax, 1   ; Example: set rax = syscall number for write()
; syscall happens here
pop rax      ; Restore original value of rax

```

This ensures that whatever was in `rax` before remains intact after the syscall.

* * *

### 5\. Practical Example with Loops

Let’s modify a small loop example to demonstrate `push` and `pop`:

```
global _start

section .text
_start:
    xor rax, rax    ; rax = 0
    xor rbx, rbx    ; rbx = 0
    inc rbx         ; rbx = 1

    push rax        ; save registers
    push rbx
    ; hypothetical syscall or function call
    pop rbx         ; restore registers (reverse order)
    pop rax

loopFib:
    add rax, rbx
    xchg rax, rbx
    cmp rbx, 10
    js loopFib

```

#### Why Reverse Order?

Because of LIFO behavior:

1.  `push rax` → rax is stored first (lower in stack).
    
2.  `push rbx` → rbx is stored last (on top).
    
3.  `pop rbx` → retrieves the *last pushed* value.
    
4.  `pop rax` → retrieves the *earlier* one.
    

* * *

### 6\. Stack Behavior in GDB

When observing with a debugger like **gdb**, you’ll notice how the stack changes:

Before `push`:

```
rsp → 0x7fffffffe410
rax = 0x0
rbx = 0x1

```

After `push rax` and `push rbx`:

```
rsp → 0x7fffffffe400
Top of stack:
  [0x7fffffffe400] = 0x0000000000000001  ; rbx
  [0x7fffffffe408] = 0x0000000000000000  ; rax

```

After `pop rbx` and `pop rax`, stack returns to original state:

```
rsp → 0x7fffffffe410
rax = 0x0
rbx = 0x1

```

Notice how values were copied — not moved — since the registers kept their data during push.

* * *

### 7\. Key 

1.  **Stack is temporary storage** — ideal for saving registers and local variables.
    
2.  **Push copies data** into the stack; it doesn’t clear the register.
    
3.  **Pop restores** the last pushed value and removes it from the stack.
    
4.  Always **pop in reverse order** of your pushes.
    
5.  You’ll use these heavily in **function calls** and **syscalls** to preserve register state.
    

* * *

&nbsp;