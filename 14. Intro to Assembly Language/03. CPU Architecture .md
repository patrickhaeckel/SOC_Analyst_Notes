---
title: "03. CPU Architecture\_"
updated: 2025-10-08 03:14:11Z
created: 2025-10-05 18:21:41Z
---

## CPU Architecture (Simplified Explanation)

The **Central Processing Unit (CPU)** is the main component responsible for executing instructions in a computer. It contains two primary parts:

1.  **Control Unit (CU):** Directs data flow between memory, registers, and other hardware.
    
2.  **Arithmetic Logic Unit (ALU):** Performs arithmetic operations (addition, subtraction, etc.) and logical operations (comparisons, bitwise operations).
    

Together, these units execute the instructions of a program, typically written in assembly language and then translated into machine code.

* * *

## Instruction Set Architecture (ISA)

The **Instruction Set Architecture (ISA)** defines *how* a CPU understands and executes instructions. It specifies the available operations, how data is stored, and how memory and registers interact.

There are two major types of ISAs:

| Type | Description | Example |
| --- | --- | --- |
| **RISC (Reduced Instruction Set Computer)** | Uses simple instructions that each perform a small, specific task. Each instruction takes fewer cycles and consumes less power. | ARM |
| **CISC (Complex Instruction Set Computer)** | Uses more complex instructions that can perform multiple tasks in a single step. Each instruction takes more time and power but may reduce the number of total instructions needed. | Intel x86 / AMD64 |

RISC focuses on *simplicity and speed per instruction*, while CISC focuses on *doing more work per instruction*.

* * *

## Clock Speed and Clock Cycle

A CPU’s **clock speed** determines how fast it processes instructions.

- The **clock** emits regular pulses (ticks), and each tick triggers a **clock cycle**.
    
- Every clock cycle allows the CPU to perform a basic operation (such as fetching or storing data).
    

Clock speed is measured in **Hertz (Hz)**:

- **1 Hz** = 1 cycle per second
    
- **3.0 GHz** = 3 billion cycles per second (per core)
    

Modern CPUs have **multiple cores**, allowing several instruction cycles to run simultaneously.

* * *

## Instruction Cycle

An **Instruction Cycle** is the process the CPU follows to execute a single machine instruction. It consists of four main stages:

| Stage | Description |
| --- | --- |
| **1\. Fetch** | The Control Unit (CU) retrieves the instruction from memory using the Instruction Address Register (IAR). |
| **2\. Decode** | The CPU decodes the binary instruction to determine what operation to perform. |
| **3\. Execute** | The ALU or CU performs the requested operation (arithmetic, logic, or data movement). |
| **4\. Store** | The result is stored back into memory or a register. |

Each instruction cycle usually spans **multiple clock cycles**, depending on the CPU design and the complexity of the instruction.

* * *

### Example: Executing `add rax, 1`

1.  **Fetch**: Retrieve instruction `48 83 C0 01` from the memory address in the `rip` register.
    
2.  **Decode**: Interpret the bytes to understand it’s an `add` of `1` to the value at `rax`.
    
3.  **Execute**: Get the current value at `rax` (by `CU`), add `1` to it (by the `ALU`)..
    
4.  **Store**: Write the new value back to `rax`.
    

Older CPUs executed instructions one at a time.  
Modern CPUs use **pipelining and multithreading** to handle multiple instructions in parallel—allowing different stages (Fetch, Decode, Execute) to overlap and significantly improve performance.

* * *

## Processor-Specific Architectures

Different processors interpret machine code differently because each has its own ISA.

For example:

- On **Intel x86_64**, `48 83 C0 01` means `add rax, 1`.
    
- On **ARM**, the same bytes might mean something entirely different, like `biceq r8, r0, r8, asr #6`.
    

Even though both processors perform arithmetic operations, their instruction sets and binary encodings are unique.

### Syntax Differences

Within the same ISA, syntax may vary by assembler:

- **Intel syntax:** `add rax, 1`
    
- **AT&T syntax:** `addb $0x1, %rax`
    

Both assemble to the same machine code but use different notations and operand order.

* * *

## Checking CPU Architecture in Linux

To check your system’s CPU architecture: `lscpu`

Example output:

```
Architecture:                    x86_64
CPU op-mode(s):                  32-bit, 64-bit
Byte Order:                      Little Endian

<SNIP>
```

Alternatively: `uname -m`

- **x86_64** → 64-bit CPU
    
- **Little Endian** → The least significant byte is stored first in memory
    

* * *

## Summary

- The **CPU** executes instructions through the **Instruction Cycle** (Fetch → Decode → Execute → Store).
    
- **Clock speed** determines how many cycles occur per second.
    
- **RISC** and **CISC** represent two different design philosophies for instruction sets.
    
- Each processor family (Intel, ARM, etc.) has its **own ISA** and may use different **assembly syntax**.
    
- Linux tools like `lscpu` and `uname -m` can reveal your system’s architecture details.
    

* * *

&nbsp;