---
title: 04. Layers 5 - 7
updated: 2025-09-07 21:57:01Z
created: 2025-09-06 07:11:10Z
---

# Layers 5–7: HTTP, HTTPS, and TLS Explained

The **Application Layer protocols** (OSI Layers 5–7) are what make networking useful to humans. At this layer, we’re no longer just sending packets — we’re sending **web pages, chat messages, emails, and streaming video.**

Two of the most important protocols here are **HTTP** and its secure cousin **HTTPS**.

* * *

## HTTP (Hypertext Transfer Protocol)

- **Purpose**: Moves web content between a client (browser) and server.
    
- **Nature**: Stateless — every request is independent, the server doesn’t “remember” past requests.
    
- **Transport**: Uses TCP (usually port 80).
    
- **Operations**: Uses methods like `GET`, `POST`, `PUT`, `DELETE`, etc.
    

Think of HTTP like **ordering food at a restaurant**:

- You (the client) make a request (order food).
    
- The server brings the response (your meal).
    
- If you want more, you ask again (another request).
    

* * *

## HTTPS (HTTP + TLS)

HTTP by itself is insecure: anyone on the same network can eavesdrop. HTTPS solves this by wrapping HTTP traffic in **TLS (Transport Layer Security)**.

- **Ports**: Usually TCP 443.
    
- **Goal**: Provide **confidentiality, integrity, and authentication.**
    
- **How**: Uses encryption and certificates.
    

Now your “restaurant order” (HTTP request) gets whispered in a **private booth** (TLS tunnel), so only you and the server can hear it.

# TLS Handshake

### 1\. **Client and server exchange hello messages**

- **ClientHello**:
    
    - Says “I’d like to start a TLS session.”
        
    - Lists supported TLS versions, cipher suites, compression methods, and extensions.
        
    - Includes a random number (Client Random).
        
- **ServerHello**:
    
    - Says “Okay, let’s use this TLS version and this cipher suite.”
        
    - Includes its own random number (Server Random).
        

At this point: both sides know **how they will talk** (protocol + cipher) and share randomness for later key derivation.

* * *

### 2\. **Client and server exchange cryptographic parameters (premaster secret setup)**

Depending on the chosen key exchange method:

- **RSA (legacy)**: Client generates premaster secret, encrypts it with server’s public key, sends it.
    
- **ECDHE/DHE (modern)**: Client and server exchange ephemeral public values and each calculates the premaster secret locally.
    

Now, both sides have the **same premaster secret**, but no one else does.

* * *

### 3\. **Exchange of certificates and authentication**

- The **server sends its certificate** (X.509) so the client can verify its identity (is this really google.com?).
    
- Sometimes the **server requests the client’s certificate** for mutual authentication (common in corporate VPNs).
    

Certificates + signatures ensure the handshake is happening with the correct entities, not an impostor (prevents MITM).

* * *

### 4\. **Generate the master secret**

- Both sides compute:

&nbsp;

* * *

## The Premaster and Master Secret

### 🔹 Premaster Secret

- A temporary value created during the handshake.
    
- In classic RSA key exchange:
    
    - The client generates the premaster secret.
        
    - It encrypts it with the server’s public key (from the certificate).
        
    - Sends it to the server.
        
    - Only the server can decrypt it (since only it has the private key).
        
- In modern **Diffie–Hellman (DH or ECDHE)**:
    
    - Both client and server contribute values.
        
    - They exchange them.
        
    - Each side combines its own private key with the other’s public value.
        
    - Result: both independently calculate the same premaster secret without actually sending it across the wire.
        

**Why important?** Because no attacker can derive the premaster secret without the private keys.

* * *

### 🔹 Master Secret

- Derived from:
    
    - The premaster secret
        
    - The client random value
        
    - The server random value
        

Formula: `MasterSecret = PRF(PremasterSecret, "master secret", ClientRandom + ServerRandom)`

(PRF = Pseudorandom Function defined by TLS standard.)

This ensures the master secret is **unique to that session**. Even if the premaster secret repeats, the random values make the master secret different.

* * *

### 🔹 Session Keys

From the master secret, TLS derives multiple keys:

- Encryption keys (one for client → server, one for server → client).
    
- MAC (Message Authentication Code) keys for data integrity.
    
- Sometimes IVs (initialization vectors) for ciphers.
    

These session keys are what encrypt your HTTP traffic.

* * *

## Quick Analogy

Imagine you and a friend want to talk in secret:

1.  You both roll dice (random values) in front of each other.
    
2.  You whisper each other a **half-secret** (DH exchange or encrypted premaster).
    
3.  By combining your half with theirs, you both end up with the same **shared secret** (premaster).
    
4.  You mix that with the dice results to create a **master secret**.
    
5.  From that, you both write down the exact same “codebook” (session keys).
    

Now you can talk freely, knowing nobody else has the codebook.

* * *

&nbsp;

&nbsp;

# Two Ways to Agree on the Premaster Secret

TLS supports multiple **key exchange mechanisms**. Let’s compare:

* * *

### 1\. RSA Key Exchange (older style)

- **Step 1:** Client generates the **premaster secret** (random bytes).
    
- **Step 2:** Client encrypts it using the server’s **public key** (from the certificate).
    
- **Step 3:** Server decrypts with its **private key**.
    
- **Result:** Both now have the same premaster secret.
    

Weakness: If someone records the handshake and later steals the server’s private key, they can decrypt the premaster and retroactively read past traffic (no forward secrecy). That’s why this method is mostly deprecated.

* * *

### 2\. Diffie–Hellman (DH or ECDHE, modern style)

This is smarter because the premaster secret is never sent.

- **Step 1:**
    
    - Client picks a random private value (`a`) and computes a public value (`g^a mod p`).
        
    - Server picks a random private value (`b`) and computes a public value (`g^b mod p`).
        
- **Step 2:** They exchange public values (`g^a mod p` and `g^b mod p`).
    
- **Step 3:**
    
    - Client computes `(g^b)^a = g^(ab)`
        
    - Server computes `(g^a)^b = g^(ab)`
        

Both arrive at the same premaster secret (`g^(ab)`), but nobody ever sent it over the wire.

ECDHE (Elliptic Curve Diffie–Hellman Ephemeral) is the modern version, using elliptic curves instead of big prime mod math. It’s faster and more secure.

Advantage: Provides **forward secrecy** — even if the server’s private key is stolen later, past sessions remain secure because each handshake used fresh, ephemeral keys.

The Master Secret in TLS

### 1\. Where it Comes From

- Both client and server first agree on a **premaster secret**.
    
    - (via RSA: client sends it encrypted, server decrypts)
        
    - (via Diffie–Hellman/ECDHE: both compute it independently)
        
- Along with that premaster secret, both sides already exchanged two random values earlier in the handshake:
    
    - **Client Random** (from ClientHello)
        
    - **Server Random** (from ServerHello)
        

* * *

### 2\. How It’s Made

The master secret is derived using all three ingredients:

`Master Secret = PRF(Premaster Secret, "master secret", Client Random + Server Random)`

- **PRF** = Pseudo-Random Function (cryptographic mixing function).
    
- **Label "master secret"** is literally a string fed in, so the PRF output is unique for this purpose.
    
- **Client + Server randoms** ensure that even if the same premaster secret happened to repeat, the resulting master secret will still be unique to this session.
    

So the **master secret is a 48-byte (384-bit) blob of randomness**, identical on both sides, but completely unpredictable to outsiders.

* * *

### 3\. What It’s Used For

The master secret is **not used directly to encrypt application data**. Instead, it’s a seed from which TLS derives all the working keys:

- **Client write key** (client → server encryption)
    
- **Server write key** (server → client encryption)
    
- **MAC keys** (integrity/authentication in each direction)
    
- **Initialization vectors** (if the cipher requires them)
    

This process is called the **key block expansion**:

`Key Block = PRF(Master Secret, "key expansion", Server Random + Client Random)`

Then the key block is split up into however many keys the chosen cipher suite needs.

* * *

### 4\. Why This Matters

- The master secret is **session-specific**. Each handshake produces a new one.
    
- Even if someone records your traffic, they cannot compute the master secret without knowing the premaster.
    
- In modern ECDHE handshakes, the premaster itself is ephemeral, so the master secret is **impossible to reconstruct later** (forward secrecy).
    

* * *

#   
<br/><br/>File Transfer Protocol (FTP)

**File Transfer Protocol (FTP)** is an **Application Layer protocol** designed for transferring files between computers over a network. It can be used from the command line, a web browser, or through a graphical FTP client such as **FileZilla**.

However, FTP is considered **insecure** because it transmits data—including usernames and passwords—in plaintext. For this reason, most modern environments have migrated to **SFTP (SSH File Transfer Protocol)** or other secure alternatives. Additionally, most web browsers dropped native FTP support around **2020**.

* * *

## Ports and Communication

Unlike many protocols that communicate over a **single socket**, FTP uses **two separate TCP ports**:

- **Port 21** → Control channel (used for authentication and issuing commands)
    
- **Port 20** → Data channel (used for transferring files)
    

This dual-channel design makes FTP unique compared to simpler client-server communication models.

### Authentication

FTP supports:

- **User authentication** with usernames and passwords.
    
- **Anonymous access**, if configured on the server.
    

* * *

## Active vs. Passive Modes

FTP can operate in two different modes depending on how the data connection is established:

### **Active Mode (default)**

- The client opens a random port and sends a **PORT command** to the server.
    
- The server then initiates the connection back to the client’s port to transfer data.
    

### **Passive Mode**

- Useful when the client is behind a firewall or NAT.
    
- The client sends a **PASV command** to the server.
    
- The server responds with the IP and port it has opened for data transfer.
    
- The client then initiates the connection to that server port.
    

* * *

## Why Firewalls Complicate Active FTP

### 1\. Active FTP requires **server → client** connections

- In **Active Mode**, the client says:  “Hey server, connect back to me on port XYZ.”
    
- The **server then initiates a TCP connection back to the client** on that port for the **data channel**.
    

### 2\. Firewalls are usually configured to block inbound connections

- Most firewalls (and NAT routers) **allow outbound traffic** (client → server), but **block unsolicited inbound traffic** (server → client).
    
- From the firewall’s perspective, that server connection looks like a **random incoming attempt** and gets blocked.
    

### 3\. NAT (Network Address Translation) makes it worse

- If the client is behind a NAT, its internal IP (like `192.168.x.x`) is not visible to the server.
    
- When the client sends the **PORT command**, it tells the server:  “Connect to 192.168.1.25 on port 12345.”
    
- But the server **cannot reach that private IP** — it only knows the NAT’s public IP. Unless the NAT device is specially configured, the server’s connection will fail.
    

##   
How Passive FTP Solves This

- In **Passive Mode**, the client always initiates **both** connections (control + data).
    
- The server simply replies with:  “Here’s the IP and port I opened, connect to me.”
    
- Since the client initiates the connection, **firewalls and NAT devices allow it** (because it’s outbound traffic).
    

&nbsp;

#### FTP Commands

| **Command** | **Description** |
| --- | --- |
| `USER` | specifies the user to log in as. |
| `PASS` | sends the password for the user attempting to log in. |
| `PORT` | when in active mode, this will change the data port used. |
| `PASV` | switches the connection to the server from active mode to passive. |
| `LIST` | displays a list of the files in the current directory. |
| `CWD` | will change the current working directory to one specified. |
| `PWD` | prints out the directory you are currently working in. |
| `SIZE` | will return the size of a file specified. |
| `RETR` | retrieves the file from the FTP server. |
| `QUIT` | ends the session. |

&nbsp;

&nbsp;

# Server Message Block (SMB) 

**Server Message Block (SMB)** is a network file-sharing protocol most commonly found in Windows enterprise environments. It allows systems to share resources such as files, printers, named pipes, and even authentication services across a network.

SMB is a **connection-oriented protocol**, meaning it requires a session between client and server, and authentication is usually necessary to ensure users have the correct permissions for resource access.

* * *

## Transport Mechanisms

SMB has evolved over time in how it is transported:

| Transport | Protocol/Port | Notes |
| --- | --- | --- |
| **NetBIOS over UDP** | UDP 137, 138 | Early implementations relied on NetBIOS for name resolution and datagram services. |
| **NetBIOS over TCP** | TCP 139 | Supported transition phase, still seen in some environments. |
| **Direct over TCP** | TCP 445 | Modern standard, SMB runs directly over TCP without NetBIOS. |
| **SMB over QUIC** | QUIC (UDP/443) | Introduced in Windows Server 2022/Windows 11 for encrypted, firewall-friendly SMB over the internet. |

&nbsp;

## Why SMB Matters

- **Convenience for users** – Provides seamless access to shared drives, printers, and authentication servers.
    
- **Attractive to attackers** – Used heavily for lateral movement, credential theft, and resource enumeration. Attackers abuse SMB to move inside a network once initial access is gained.
    

* * *

## SMB on the Wire

Like any TCP-based application, SMB traffic starts with the **three-way handshake** (SYN → SYN/ACK → ACK) before higher-level negotiation begins.

### Example Traffic Highlights

From a packet capture between `192.168.199.132` and `192.168.199.133`:

- **TCP Handshake (Orange boxes)**  
    Every new session begins with a handshake, establishing a reliable connection.
    
- **SMB over Port 445 (Blue box)**  
    Destination port indicates direct TCP transport — the modern SMB standard.
    
- **SMB Info Fields (Green boxes)**  
    Show session negotiation, authentication attempts, and errors.
    
    - A few failed logons → could be user error.
        
    - Repeated failures in a short timeframe → possible brute force attempt or credential misuse.
        

### Security Implications

- **Brute force / credential stuffing** – Multiple logon failures may indicate an attacker testing passwords.
    
- **Lateral movement** – Attackers often use stolen credentials to connect to file shares and pivot across systems.
    
- **Unusual file access** – A host unexpectedly accessing shares on many machines is suspicious and worth deeper analysis.
    

* * *

## Key Takeaways

- SMB is fundamental in Windows networks, but also a **prime attack surface**.
    
- Normal behavior: access to printers, shared drives, domain controllers.
    
- Abnormal behavior: repeated authentication failures, unusual file-share access, or cross-host enumeration.
    
- Monitoring SMB traffic can help detect early signs of compromise.
    

#   
Example: SMB Traffic Walkthrough

Imagine we capture traffic between two hosts:

- **Client:** `192.168.10.20`
    
- **Server:** `192.168.10.50`
    
- **Protocol:** SMB over TCP/445
    

* * *

## Step 1 – TCP Handshake

| Source → Destination | Protocol | Info |
| --- | --- | --- |
| 192.168.10.20 → 192.168.10.50 | TCP | SYN, port 445 |
| 192.168.10.50 → 192.168.10.20 | TCP | SYN/ACK, port 445 |
| 192.168.10.20 → 192.168.10.50 | TCP | ACK |

Connection established. SMB session can now be negotiated.

* * *

## Step 2 – SMB Protocol Negotiation

| Source → Destination | Protocol | Info |
| --- | --- | --- |
| 192.168.10.20 → 192.168.10.50 | SMB2 | Negotiate Protocol Request |
| 192.168.10.50 → 192.168.10.20 | SMB2 | Negotiate Protocol Response |

**What’s happening:**  
The client asks: “Which SMB dialects do you support?”  
The server responds: “I support SMB2.1 and SMB3.0, let’s use SMB3.0.”

* * *

## Step 3 – Session Setup (Authentication)

| Source → Destination | Protocol | Info |
| --- | --- | --- |
| 192.168.10.20 → 192.168.10.50 | SMB2 | Session Setup Request (NTLMSSP_NEGOTIATE) |
| 192.168.10.50 → 192.168.10.20 | SMB2 | Session Setup Response (NTLMSSP_CHALLENGE) |
| 192.168.10.20 → 192.168.10.50 | SMB2 | Session Setup Request (NTLMSSP_AUTH, user = TEST\\jdoe) |
| 192.168.10.50 → 192.168.10.20 | SMB2 | Session Setup Response, **STATUS_LOGON_FAILURE** |

**What’s happening:**

- The client tries NTLM authentication.
    
- The server issues a challenge.
    
- The client responds with credentials for `TEST\jdoe`.
    
- Authentication fails (wrong password or invalid user).
    

If this pattern repeats many times, it may indicate brute force attempts.

* * *

## Step 4 – Retry with Correct Credentials

| Source → Destination | Protocol | Info |
| --- | --- | --- |
| 192.168.10.20 → 192.168.10.50 | SMB2 | Session Setup Request (NTLMSSP_AUTH, user = TEST\\jdoe) |
| 192.168.10.50 → 192.168.10.20 | SMB2 | Session Setup Response, STATUS_SUCCESS |

User `jdoe` authenticated successfully, session established.

* * *

## Step 5 – Tree Connect (Accessing a Share)

| Source → Destination | Protocol | Info |
| --- | --- | --- |
| 192.168.10.20 → 192.168.10.50 | SMB2 | Tree Connect Request to `\\192.168.10.50\Share` |
| 192.168.10.50 → 192.168.10.20 | SMB2 | Tree Connect Response |

The client maps a shared folder. If this were malicious, the attacker might try accessing `C$` (admin share) or sensitive directories.

* * *

# How to Read This in Wireshark

- **TCP setup** → Look for SYN/SYN-ACK/ACK on port 445.
    
- **Negotiate Protocol** → Usually the first SMB messages.
    
- **Session Setup** → Where authentication happens (watch for `STATUS_LOGON_FAILURE`).
    
- **Tree Connect** → Indicates which share is being accessed.
    
- **File Access** → Look for `Create Request`, `Read Request`, `Write Request`.
    

* * *

#   
How SMB Handles Passwords

## 1\. Old SMB (SMB1 + LANMAN/NTLMv1)

- In very old implementations (SMB1 with LANMAN/NTLMv1), weak hashing was used.
    
- The **password hash** (not the raw password) was sent across the wire.
    
- Problem: attackers could capture the hash and use **pass-the-hash (PtH)** or crack it offline.
    
- That’s why SMB1/NTLMv1 are considered insecure today.
    

* * *

## 2\. NTLM (Common in SMB2/3)

- When NTLM authentication is used, the **password itself is never sent**.
    
- Instead, the server sends a **random challenge**.
    
- The client responds with a **hash of the password + the challenge**.
    
- The server verifies by comparing it against its own calculation.
    

This means the password itself is protected, but the **hash response can be replayed** if not protected by session security → again, pass-the-hash risk.

* * *

## 3\. Kerberos (Preferred in AD Environments)

- In Active Directory domains, SMB usually uses **Kerberos**.
    
- The client requests a **ticket** from the Domain Controller (KDC).
    
- The ticket (encrypted blob) is sent to the SMB server for access.
    
- No password or hash is sent over the wire.
    

This is more secure than NTLM, but attackers can still steal Kerberos tickets (**pass-the-ticket attacks**).

* * *

## 4\. SMB Encryption (SMB 3.x)

- Starting with SMB 3.0, **end-to-end encryption** can be enabled.
    
- This protects not only authentication, but also the **entire session traffic** (file reads, writes, etc.).
    
- Used heavily in modern Windows networks.
    

* * *

- Passwords are **never sent in plaintext** with NTLM or Kerberos.
    
- Capturing SMB traffic can still expose **hashes, challenges, or tickets**, which attackers can replay or crack.
    
- Modern defense: disable SMB1, enforce SMB signing, enable SMB encryption, and prefer Kerberos.
    

* * *

#   
Why Use a Challenge–Response Scheme

## 1\. If only the password hash were sent

- The client would send its stored password hash to the server.
    
- An attacker capturing that traffic could simply replay the same hash to log in — no cracking needed.
    
- This is exactly what **pass-the-hash** attacks exploit in weaker protocols.
    

* * *

## 2\. With challenge–response (NTLM example)

1.  **Server generates a random challenge** (unique each time).
    
2.  **Client combines password hash + challenge**, runs it through a function, and sends the result.
    
3.  **Server checks** by running the same function (using its own copy of the user’s password hash in the SAM/AD).
    

&nbsp;Because the challenge is random and changes per session, the attacker can’t just replay a previously captured response. They’d need the actual password hash to recompute a valid answer.

* * *

## 3\. Benefits

- Stops simple replay of captured hashes.
    
- The password itself never traverses the network.
    
- Still vulnerable to **offline cracking** (if the attacker captures the challenge + response, they can brute force the password until the math matches).
    
- Still vulnerable to **pass-the-hash** if they already possess the password hash from the victim system.
    

* * *

## 4\. Kerberos vs NTLM

- NTLM = challenge–response, relies on password hashes.
    
- Kerberos = ticket-based, no password/hash ever sent over the wire, stronger against replay.
    

* * *

&nbsp;