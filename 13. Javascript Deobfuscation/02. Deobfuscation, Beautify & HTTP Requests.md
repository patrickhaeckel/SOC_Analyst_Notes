---
title: 02. Deobfuscation, Beautify & HTTP Requests
updated: 2025-10-06 05:29:47Z
created: 2025-10-01 00:27:41Z
---

## Understanding JavaScript Obfuscation and Deobfuscation

### What is Obfuscated Code?

Obfuscated JavaScript code is deliberately made hard to read. Common techniques include:

- **Minification**: Removing whitespace, shortening variable names (e.g., `xhr`, `url`, `f`, etc.).
    
- **Packing**: Wrapping code in an `eval(function(p,a,c,k,e,d)...` pattern using encoded symbols and tokens.
    
- **String encoding**, **function aliasing**, and **eval use** also increase complexity.
    

* * *

## Step 1: Beautify the Code

### Tools to Beautify (Format) Code:

These tools don’t deobfuscate but reformat the code for easier viewing.

#### 1\. **Browser Dev Tools**

- In **Firefox**, press `CTRL + SHIFT + Z` to open the **Debugger**.
    
- Load `secret.js`.
    
- Click the `{ }` (Pretty Print) icon to beautify the code.
    

#### 2\. **Online Beautifiers**

- Prettier
    
- JS Beautifier Beautifying ≠ Deobfuscating — it just formats the code to be readable but not necessarily understandable.
    

* * *

## Step 2: Deobfuscate the Code

### Tools for Deobfuscation

Now we go beyond formatting and try to decode what the obfuscated code is doing.

#### Use UnPacker

#### or JSNice

- Paste the `eval(function(p,a,c,k,e,d)...` code into the tool.
    
- Click **Unpack**.
    
- Result: Cleaned code with meaningful variable names and restored logic.
    

* * *

## Manual Deobfuscation Insight

If automated tools fail (e.g., due to **custom obfuscation**), follow this approach:

### Manual Reverse Engineering Tips

- **Replace `eval(...)` with `console.log(...)`** to print the real code instead of executing it blindly.
    
- Trace how strings or functions are built using things like `.replace()`, `.charCodeAt()`, etc.
    
- Use breakpoints in browser Dev Tools to inspect runtime values.
    

* * *

## Code Function Analysis: `generateSerial()`

```
'use strict';
function generateSerial() {
    var xhr = new XMLHttpRequest();
    var url = "/serial.php";
    xhr.open("POST", url, true);
    xhr.send(null);
}

```

### Line-by-Line Breakdown:

| Code | Meaning |
| --- | --- |
| `var xhr = new XMLHttpRequest();` | Creates a new HTTP request object. |
| `var url = "/serial.php";` | Defines the target path of the POST request. |
| `xhr.open("POST", url, true);` | Initializes a POST request to `/serial.php`, asynchronously. |
| `xhr.send(null);` | Sends the request with no payload. |

* * *

## Testing the Code’s Effect Using `cURL`

You can replicate the JS functionality using `cURL` in your terminal.

### Basics of cURL

`curl http://SERVER_IP:PORT/`

This fetches the main HTML page (like the homepage).

* * *

### Sending a POST Request Like the JS Code

`curl -s -X POST http://SERVER_IP:PORT/serial.php`

- `-s`: Silent mode (cleans up output).
    
- `-X POST`: Specifies a POST method.
    
- **No data** is sent, mimicking the JS function.  
    <br/>You’re replicating `xhr.send(null);` exactly with this.
    

* * *

### Adding POST Data (if needed)

If the JavaScript later includes POST data, add it like this:

`curl -s -X POST -d "param1=value" http://SERVER_IP:PORT/serial.php`

- `-d`: Sends form data in `key=value` format

* * *

## Why This Matters

By using **deobfuscation and HTTP replication**, you can:

- Discover **hidden or unused functionality**.
    
- Find **unpublished server-side features** that may be insecure or buggy.
    
- Spot **potential vulnerabilities** from incomplete or abandoned features.
    

* * *

## Summary

| Step | What You Do | Tools |
| --- | --- | --- |
| 1\. Beautify | Make code readable | Dev Tools, Prettier |
| 2\. Deobfuscate | Understand code logic | UnPacker, JSNice |
| 3\. Analyze | Review functionality | Manual inspection |
| 4\. Replicate | Simulate behavior | cURL or Postman |
| 5\. Test Server | Probe endpoints | Burp Suite or browser dev tools |

* * *

&nbsp;