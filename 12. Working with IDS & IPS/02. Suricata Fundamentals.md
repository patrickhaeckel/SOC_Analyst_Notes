---
title: 02. Suricata Fundamentals
updated: 2025-09-21 03:07:50Z
created: 2025-09-21 02:44:45Z
---

# Suricata Fundamentals

Suricata is a powerful open-source tool used as a **Network Intrusion Detection System (IDS)**, **Intrusion Prevention System (IPS)**, and **Network Security Monitoring (NSM)** platform. Developed and maintained by the **Open Information Security Foundation (OISF)**, it benefits from a strong community-driven, non-profit model.

Its primary goal is to **analyze all network traffic** in real time, detecting suspicious or malicious activity. Suricata not only provides a **broad view of network health** but can also **inspect application-layer protocols** like HTTP, DNS, or TLS. Detection is driven by a **rule set** that defines what to look for—whether threats, anomalies, or specific patterns of interest.

Suricata is designed for **high performance**, capable of running on both commodity hardware and specialized appliances.

* * *

# Suricata Operation Modes

Suricata can operate in four main modes:

1.  **Intrusion Detection System (IDS)**
    
    - Works as a *passive sensor* (does not block traffic).
        
    - Inspects packets and raises alerts if suspicious activity is detected.
        
    - Useful for gaining visibility and improving response times, but it doesn’t actively stop attacks.
        
2.  **Intrusion Prevention System (IPS)**
    
    - Works *inline*, meaning all traffic must pass through Suricata.
        
    - Blocks or allows traffic based on rules.
        
    - Provides proactive protection, but requires careful tuning to avoid false positives and potential latency.
        
3.  **Intrusion Detection & Prevention System (IDPS)**
    
    - Hybrid mode combining IDS visibility with limited IPS action.
        
    - Suricata passively observes traffic but can also send **reset (RST) packets** to disrupt malicious connections.
        
    - Balances low latency with active defense.
        
4.  **Network Security Monitoring (NSM)**
    
    - Focuses on **logging and collecting traffic data** (flows, transactions, metadata).
        
    - Doesn’t block or interfere with traffic.
        
    - Ideal for forensic analysis and investigations, though it generates large amounts of data.
        

* * *

# Suricata Inputs

Suricata can process traffic from different input sources:

- **Offline Input (PCAP files)**
    
    - Reads previously captured packets from `.pcap` files.
        
    - Useful for forensic analysis, replaying attacks, or testing new rule sets.
        
- **Live Input (real-time traffic)**
    
    - **LibPCAP**: Reads directly from a network interface; simple but limited in performance and scalability.
        
    - **NFQ (Netfilter Queue)**: Linux-specific inline IPS option; works with IPTables to forward packets to Suricata for inspection and dropping.
        
    - **AF_PACKET**: High-performance packet capture supporting multi-threading; faster than LibPCAP, but requires modern Linux and can’t always be used inline if routing is also needed.
        

* * *

# Suricata Outputs

Suricata produces multiple types of outputs, including:

- **Logs & Alerts**: Records detections, anomalies, and activity.
    
- **EVE JSON** (most important):
    
    - Rich, structured log format.
        
    - Includes alerts, HTTP metadata, DNS queries, TLS info, flow records, SMTP metadata, and more.
        
    - Easily integrated into log management and analysis pipelines (e.g., ELK stack).
        
- **Unified2 Format**:
    
    - A legacy Snort-compatible binary alert format.
        
    - Useful for integrating Suricata with tools that already process Snort alerts.
        
    - Can be parsed with Snort’s `u2spewfoo` tool.
        

* * *

&nbsp;

# 1) Suricata Overview

Suricata is an open-source network security engine used for IDS, IPS and NSM. It inspects packets and application-layer transactions using signature rules and protocol parsers, runs on commodity or specialized hardware, and supports offline (PCAP) and live inputs (libpcap, AF_PACKET, NFQUEUE). Detection is driven by rule files plus variables (e.g., `$HOME_NET`), configuration in `suricata.yaml`, and optional rule management via `suricata-update`. You typically develop and test rules offline (PCAP), validate them, then deploy them in IDS mode before switching to inline/IPS.

* * *

# 2) Practical file locations & essentials

- Main config: `/etc/suricata/suricata.yaml`
    
- Rule directory: `/etc/suricata/rules/` (may vary by distro/package)
    
- EVE JSON log (rich events): usually under `/var/log/suricata/eve.json`
    
- Common logs: `fast.log`, `stats.log`
    
- Rules management: `suricata-update` (if installed)
    
- Service control (systemd): `sudo systemctl {start|stop|restart|status} suricata`
    

* * *

# 3) Common commands (cheat sheet)

| Command | What it does | Notes / flags |
| --- | ---: | --- |
| `ls -lah /etc/suricata/rules/` | list installed rules |     |
| `more /etc/suricata/rules/<file>.rules` | view a rule file |     |
| `sudo nano /etc/suricata/suricata.yaml` | edit config | back up first |
| `suricata -T -c /etc/suricata/suricata.yaml` | test config + rules | must succeed before restarting service |
| `suricata -r /path/file.pcap` | offline PCAP analysis (creates logs) | use `-k none` to skip checksum checks; `-l .` to set output dir |
| `suricata -r file.pcap -k none -l .` | offline with checksum bypass and custom log dir |     |
| `sudo suricata --pcap=eth0 -vv` | live capture via libpcap | `-vv` verbose |
| `sudo suricata -i eth0` | start in IDS using AF_PACKET on interface |     |
| `sudo suricata --af-packet=eth0` | AF_PACKET capture (high perf) |     |
| `sudo suricata -q 0` | NFQ queue 0 (inline/NFQ) | requires `iptables` NFQUEUE rules |
| `sudo iptables -I FORWARD -j NFQUEUE` | send forwarded packets to NFQUEUE | tune chain/selector in production |
| `sudo tcpreplay -i eth0 suspicious.pcap` | replay traffic to test live Suricata |     |
| `sudo systemctl restart suricata` | reload rules/config when used as a service |     |
| `suricata-update` | fetch/enable updated rule sets (if installed) |     |
| `tail -f /var/log/suricata/eve.json` | watch events live | pipe to `jq` for readability |

* * *

# 4) Rule basics & one-line recipe for a custom rule

A Suricata/Snort rule format (minimal):

`action proto src_ip src_port -> dst_ip dst_port ( options )`

Example rule (alert HTTP GET for `/badpath`):

`alert http any any -> $HOME_NET any ( msg:"CUSTOM_HTTP_BADPATH"; flow:to_server,established; http.uri; content:"/badpath"; nocase; sid:1000001; rev:1; classtype:web-application-attack; priority:1; )`

Breakdown:

- `alert` = action (other actions: `drop`, `reject`, `log`, `pass`)
    
- `http` = layer/protocol to match (http parser needed)
    
- `any any -> $HOME_NET any` = traffic direction and ports (use variables!)
    
- `msg:` = human message shown in logs
    
- `flow:` = session direction/flags (e.g., `to_server,established`)
    
- `http.uri` / `content:` = matchers (content match inside HTTP URI)
    
- `nocase` = case-insensitive match
    
- `sid:` = unique rule ID — use local SID space (commonly ≥ 1,000,000)
    
- `rev:` = revision number — increment when you change the rule
    

Rules typically go in a `.rules` file under `/etc/suricata/rules/`. After adding a rule, test with `suricata -T` and run it against a pcap before enabling inline blocking.

* * *

# 5) Variables & tuning

- `$HOME_NET` = your internal network (define in `suricata.yaml`), e.g., `192.168.0.0/24` or `[192.168.0.0/24,10.0.0.0/8]`
    
- `$EXTERNAL_NET` = network considered external (often `!$HOME_NET`)
    
- Keep variables specific — broad `$HOME_NET any` increases false positives.
    
- Tune detection engine options (stream reassembly, flow timeouts) in `suricata.yaml` for performance/accuracy.
    

* * *

# 6) Inputs explained (short)

- **Offline (PCAP)**: best for testing and forensics. Command: `suricata -r file.pcap`.
    
- **LibPCAP**: simple live capture; lower performance, single-threaded limits.
    
- **AF_PACKET**: high-performance capture with multi-threading and mmap; preferred for busy sensors (modern Linux required).
    
- **NFQUEUE (NFQ)**: inline IPS mode. Kernel queues packets to userspace; Suricata can drop/accept. Requires iptables/nft rules that direct packets into NFQUEUE.
    

Important: test rules and behavior in IDS mode first — moving to NFQ/IPS without validation risks blocking legitimate traffic.

* * *

# 7) How to safely develop & deploy custom rules

1.  **Backup** current config and rule files.  
    `sudo cp /etc/suricata/suricata.yaml /etc/suricata/suricata.yaml.bak` and copy rule files.
    
2.  **Define variables** in `suricata.yaml` for `$HOME_NET`, `$EXTERNAL_NET`.
    
3.  **Create new rule file** (e.g., `/etc/suricata/rules/local.rules`) and add custom rules with SIDs in a local range (≥1000000).
    
4.  **Test locally**: `suricata -T -c /etc/suricata/suricata.yaml` — fix any errors.
    
5.  **Validate against PCAP**: `suricata -r test.pcap -S /etc/suricata/rules/local.rules -l ./out` (or run with full config). Inspect `eve.json`, `fast.log`.
    
6.  **Tweak** the rule (content, flow, pcre) to reduce false positives. Increase `rev:` when updating.
    
7.  **Deploy in IDS (monitor) mode** on the live network for a period and observe alerts.
    
8.  **Move to inline/IPS** only after thorough testing & whitelisting. Maintain monitoring and rollback plan.
    

* * *

# 8) Quick testing tools & tips

- Use `tcpreplay` to inject test PCAPs into a live interface (good for reproducing alerts).
    
- Use `tcpdump -w test.pcap` to capture traffic you want to analyze.
    
- Use `jq` to pretty-print EVE JSON: `jq '.' /var/log/suricata/eve.json | less`.
    
- `u2spewfoo` can parse Unified2 outputs if you need Snort compatibility.
    
- Watch CPU/memory when switching to AF_PACKET or NFQ — inline modes add processing cost.
    

* * *

# 9) Common pitfalls & mitigation

- **False positives** — tune rule content, `flow`, and add `threshold` or `rate` controls. Test extensively.
    
- **Blocking legitimate traffic in IPS** — always run a period in IDS mode; create whitelist rules.
    
- **Performance drop** — use AF_PACKET with multiple threads, pin threads/cores, adjust ring/mmap settings.
    
- **SID collisions** — use a clearly defined local SID space (e.g., `1000000+`) for custom rules.
    
- **Config errors** — always run `suricata -T` before restarting service.
    

* * *

# 10) Minimal checklist before switching to IPS/inline

- All custom rules validated against representative PCAPs.
    
- `suricata -T` returns OK.
    
- Monitoring/alerting pipeline in place (EVE → SIEM/ELK).
    
- Whitelist/allow rules created for known good services.
    
- Resource monitoring (CPU, packet drops) baseline captured.
    
- Rollback plan to IDS mode or remove NFQUEUE iptables rule.
    

* * *

# 11) Useful small examples

View rules directory: `sudo ls -lah /etc/suricata/rules/`

View a rule file: `sudo less /etc/suricata/rules/emerging-malware.rules`

Test suricata config: `sudo suricata -T -c /etc/suricata/suricata.yaml`

Offline pcap processing (write logs in current dir): `suricata -r /opt/pcaps/suspicious.pcap -k none -l .`

Start AF_PACKET IDS on eth0: `sudo suricata --af-packet=eth0 -c /etc/suricata/suricata.yaml`

Set NFQUEUE rule (inline test) and start suricata on queue 0: `sudo iptables -I FORWARD -j NFQUEUE --queue-num 0sudo suricata -q 0 -c /etc/suricata/suricata.yaml`

Replay pcap to interface eth0: `sudo tcpreplay -i eth0 /opt/pcaps/suspicious.pcap`

Add a simple custom rule in /etc/suricata/rules/local.rules: `alert tcp any any -> $HOME_NET 80 (msg:"LOCAL test HTTP /evil"; flow:to_server,established; http.uri; content:"/evil"; nocase; sid:1000001; rev:1;)`

* * *

# 12) Log Analysis & Event Filtering

Suricata writes its logs by default to **`/var/log/suricata/`**, usually requiring root access to read. The three most important logs:

- **`eve.json`**
    
    - JSON-formatted, the *recommended* output.
        
    - Contains all event types: alerts, DNS queries, TLS handshakes, SSH, HTTP metadata, etc.
        
    - Easily filtered with `jq`:
        
- ```
    # View only alerts 
    cat /var/log/suricata/eve.json | jq 'select(.event_type == "alert")'
    # First DNS event 
    cat /var/log/suricata/eve.json | jq 'select(.event_type == "dns")' | head -1 | jq .
    ```
    
    - **Key fields**:
        
        - `flow_id`: unique identifier per flow (helps correlate alerts/transactions).
            
        - `pcap_cnt`: packet counter, maps back to PCAP order (offline mode).
            
- **`fast.log`**
    
    - Lightweight text log of alerts only.
        
    - Default format: `timestamp [sid:rev] signature {proto} src:port -> dst:port`.
        
    - Quick for troubleshooting, but less context than `eve.json`.
        
- **`stats.log`**
    
    - Human-readable counters and performance stats.
        
    - Great for debugging and performance monitoring: packet drops, memory usage, flow counts, etc.
        

* * *

# 13) File Extraction (Filestore)

Suricata can capture and store files transmitted over HTTP, SMTP, FTP, SMB, etc. Useful for **threat hunting, malware analysis, or forensics**.

### Configuration (`suricata.yaml`)

```
file-store:
  version: 2
  enabled: yes
  force-filestore: yes
  dir: /var/log/suricata/filestore

```

- `enabled: yes` → turn on extraction.
    
- `force-filestore: yes` → store all matched files (without relying on specific rule `filestore` options).
    
- Files are saved with **SHA256 hash as filename**, grouped by first two hex chars (`00`–`ff` subdirs).
    

### Example Rule for Extraction (`local.rules`)

`alert http any any -> any any (msg:"FILE store all"; filestore; sid:1000002; rev:1;)`

### Running Suricata with PCAP

`suricata -r /path/to/file.pcap`

Result: `eve.json`, `fast.log`, `stats.log`, `suricata.log` + new `filestore/` directory.

Inspect stored file headers:

```
cd /var/log/suricata/filestore
xxd ./21/<sha256filename> | head

```

If the header starts with `MZ` → Windows PE file, `PK` → ZIP/Office doc, `%PDF` → PDF, etc.

* * *

# 14) Live Rule Reloading

Avoid downtime when updating rules.

- Enable in `suricata.yaml`:
    
- ```
    detect-engine:
      - reload: true
    
    ```
    
- Reload without restart:
    
- ```
    sudo kill -usr2 $(pidof suricata)
    
    ```
    

Suricata will re-read rule files and apply changes in place.

* * *

# 15) Updating Rulesets with `suricata-update`

`suricata-update` handles fetching, enabling, and disabling rulesets.

- Basic update:
    
- `sudo suricata-update`
    
- List available rule sources:
    
- `sudo suricata-update list-sources`
    
- Enable a specific source (e.g., Emerging Threats Open):
    
- `sudo suricata-update enable-source et/open`   `sudo suricata-update`
    
- Restart Suricata service if needed:
    
- `sudo systemctl restart suricata`
    

* * *

# 16) Configuration Validation

Always validate configs after changes:

`sudo suricata -T -c /etc/suricata/suricata.yaml`

- Checks YAML syntax.
    
- Ensures rule files exist and parse correctly.
    
- Fails fast before production deployment.
    

* * *

# 17) Key Features Recap

Suricata provides:

- Deep packet inspection (L2–L7).
    
- IDS, IPS, and NSM modes.
    
- JSON-rich output (`eve.json`).
    
- File extraction (with hashing).
    
- Protocol anomaly detection.
    
- Lua scripting support.
    
- GeoIP integration.
    
- IPv4/IPv6 dual stack.
    
- Flow correlation (`flow_id`).
    
- Multi-threading and high-performance packet capture.
    

* * *

# 18) Practical Tips

- Use **`jq`** + **`less`** for log analysis:
    
- `jq . /var/log/suricata/eve.json | less`
    
- Integrate `eve.json` into a SIEM (ELK, Splunk, etc.) for dashboards.
    
- Use `tcpreplay` + test PCAPs for verifying custom rules.
    
- Maintain a **local.rules** file with SIDs ≥ 1,000,000.
    
- Always test in IDS mode first before IPS.
    
- Monitor performance in `stats.log` for packet drops.