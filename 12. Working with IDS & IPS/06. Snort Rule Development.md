---
title: 06. Snort Rule Development
updated: 2025-09-30 05:16:11Z
created: 2025-09-26 00:36:02Z
---

1) Quick primer: Snort rule anatomy (plain language)

A Snort rule has two parts:

- **Header** — defines protocol, source → destination and basic action. Example:  
    `alert tcp $HOME_NET any -> $EXTERNAL_NET any`  
    Means: alert on TCP traffic from our network to external networks.
    
- **Options** (inside parentheses) — powerful matching instructions (content, flow, pcre, sid, rev, etc.). They control *what* in the packet/payload to inspect and *how* to alert.
    

Key terms you’ll see:

- `flow:established,to_server` — only look at packets in an already established TCP connection going client→server.
    
- `content:"foo"` — look for plain text `foo` in the relevant buffer.
    
- `|xx yy|` — bytes in hex inside pipes; e.g. `|3a 20|` = `:` (colon + space).
    
- `depth`, `distance`, `within` — limit where Snort looks relative to previous matches or the start of the buffer.
    
- `http_*` keywords (e.g., `http_uri`, `http_client_body`, `http_header`) — use normalized HTTP buffers assembled by the HTTP preprocessor; these handle multi-packet HTTP requests better than raw `content`.
    
- `pcre:"/regex/"` — a regex match.
    
- `fast_pattern` — hints Snort to use this content as the fast index for quicker matching.
    
- `dsize` — size of the payload (useful for UDP).
    
- `detection_filter` (or `threshold`) — limits noisy alerts (e.g., only alert if N matches in X seconds).
    
- `sid`, `rev`, `classtype` — metadata for detection management.
    

Important caveat: **payloads can be split across packets** (TCP segmentation) — that’s where “sticky” or assembled buffers matter. Using raw `content` with `depth` may miss strings split across packets; `http_client_body`/`http_header`/`http_uri` read the normalized HTTP buffer and avoid that problem.

* * *

# 2) Example rules — plain, precise explanation + how they can fail

## Example 1 — Ursnif (given rule)

Rule given:

```
alert tcp any any -> any any (msg:"Possible Ursnif C2 Activity";
  flow:established,to_server;
  content:"/images/", depth 12;
  content:"_2F";
  content:"_2B";
  content:"User-Agent|3a 20|Mozilla/4.0 (compatible|3b| MSIE 8.0|3b| Windows NT";
  content:!"Accept";
  content:!"Cookie|3a|";
  content:!"Referer|3a|";
  sid:1000002; rev:1;)

```

What it’s doing (step-by-step):

1.  Only matching established TCP connections that go client → server.
    
2.  Requires the literal string `/images/` to appear within the first 12 bytes of the payload (`depth 12`).
    
3.  Also requires `_2F` and `_2B` somewhere in the payload.
    
4.  Requires a very specific `User-Agent` string (with hex escapes `|3a 20|` = `:` and `|3b|` = `;`).
    
5.  Requires the **absence** of headers: `Accept`, `Cookie:`, and `Referer:` (`content:!"..."` is a negation).
    
6.  If all those conditions hold, it raises alert `sid:1000002`.
    

Why it’s **inefficient** or brittle:

- `depth 12` is very restrictive and can cause misses if `/images/` appears later or is split across packets.
    
- Using plain `content` to look for HTTP headers is less reliable than `http_header`, `http_uri`, `http_client_body` because of packet reassembly / sticky buffers.
    
- Negated `content:!"Accept"` may fail if a client sends `Accept: */*` — it needs careful logic: “absence” checks are fragile unless you inspect the normalized HTTP header buffer.
    
- Using multiple separate `content` tests without `fast_pattern` or `http_*` anchoring can be slow.
    

**How to improve** (high level):

- Use `http_header`, `http_uri`, `http_client_body` to search assembled HTTP buffers.
    
- Use `fast_pattern` on a short, reliable string to speed up matching.
    
- Replace `depth` with `http_uri`/`http_header` matches (they search normalized data).
    
- Consider a `pcre` if the pattern is complex and spans multiple fields.
    

* * *

## Example 2 — Cerber (UDP)

Rule:

```
alert udp $HOME_NET any -> $EXTERNAL_NET any (msg:"Possible Cerber Check-in";
  dsize:9;
  content:"hi", depth 2, fast_pattern;
  pcre:"/^[af0-9]{7}$/R";
  detection_filter:track by_src, count 1, seconds 60;
  sid:2816763; rev:4;)

```

What it’s doing:

1.  Only UDP traffic from home to external.
    
2.  `dsize:9` — payload must be exactly 9 bytes.
    
3.  First two bytes must be `hi` (`depth 2`), and this is marked `fast_pattern` so the engine indexes on it.
    
4.  After `hi` the rest must match 7 hex characters (regex `^[af0-9]{7}$`) — so total payload = `hi` + 7 hex chars = 9 bytes.
    
5.  `detection_filter:track by_src, count 1, seconds 60` — this is odd in this form: it means “track by source, threshold count 1 in 60s”; usually used to suppress very noisy alerts, but with `count 1` it’s effectively minimal — double-check this if you want rate limiting.
    

Why this is reasonable:

- `dsize` + `pcre` + `fast_pattern` makes it precise and efficient for this small, fixed-length beacon.

Pitfalls:

- If the malware changes the length or varies the prefix, it won’t match.
    
- UDP fragmentation or intermediate devices changing payloads may break matches (usually less of a problem than TCP segmentation).
    

* * *

## Example 3 — Patchwork (HTTP POST with sticky buffers)

Rule:

```
alert http $HOME_NET any -> $EXTERNAL_NET any (msg:"...Patchwork...";
  flow:established,to_server;
  http_method; content:"POST";
  http_uri; content:".php?profile=";
  http_client_body; content:"ddager=", depth 7;
  http_client_body; content:"&r1=", distance 0;
  http_header; content:!"Accept";
  http_header; content:!"Referer|3a|";
  sid:10000006; rev:1;)

```

What it’s doing:

1.  Uses `http_*` keywords — this means Snort’s HTTP preprocessor has assembled headers and client body into buffers that are easier to search across packets (solves sticky / split packets).
    
2.  Checks the method is POST, the URI contains `.php?profile=`, and inside the HTTP request body looks for `ddager=` followed immediately (distance 0) by `&r1=` — very specific ordering.
    
3.  Also checks the absence of `Accept` and `Referer:` headers in the HTTP header buffer.
    

Why this is better than literal `content`:

- `http_client_body` and `http_header` use reassembled buffers and are much more robust to packet boundaries and TCP segmentation.

Caveat:

- Negation of a header (`content:!"Accept"`) will only be correct if the header truly is absent in the normalized header buffer. If the client sends even an empty header or the header name occurs in another header value, tests can be confused.

* * *

## Example 4 — Patchwork (SSL / cert)

Rule:

```
alert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:"Patchwork SSL Cert Detected";
  flow:established,from_server;
  content:"|55 04 03|";
  content:"|08|toigetgf", distance 1, within 9;
  classtype:trojan-activity;
  sid:10000008; rev:1;)

```

What it’s doing:

1.  Looking at packets from server → client in an established flow (so likely the TLS handshake from server).
    
2.  `|55 04 03|` — hex bytes that correspond to the ASN.1 tag for the X.509 **Common Name** (CN) field in a certificate. After that ASN.1 tag, it expects the bytes `|08|` (ASN.1 tag for an OCTET STRING with length 8) followed by the ASCII `toigetgf` within a short window (`distance 1, within 9`).
    
3.  In short: look inside the server certificate for a CN value equal (or near) `toigetgf`.
    

Why this is clever:

- It inspects DER/ASN.1 bytes in the TLS handshake (server cert) rather than plaintext, so it can detect malicious certificates even if the rest of the TLS payload is encrypted.

Caveat:

- If the cert encodes CN differently, or uses subjectAltName, or length fields differ, exact distance/within numbers can miss; parsing DER reliably is tricky using simple content matches — but for targeted detection this often works.

&nbsp;

* * *

## A — Tools you’ll use

- `tcpdump` to capture: `sudo tcpdump -i any -w /tmp/test.pcap`
    
- `nc` (netcat) or `socat` to send/receive raw TCP/UDP.
    
- `curl` for HTTP, but for precise header absence use raw sockets (nc) and craft a raw HTTP request.
    
- `openssl` to create a certificate and run a test TLS server.
    
- `snort` to test rules on the created pcap:  
    `sudo snort -c /path/to/snort.lua -R local.rules -r /tmp/test.pcap -A cmg`
    

* * *

## B — Generate a test PCAP for the **Cerber UDP** rule

We need a UDP packet exactly 9 bytes: `hi` + 7 hex chars (e.g. `hiabcdef0`).

1.  Start a capture:

```
sudo tcpdump -i any udp and host 1.2.3.4 -w /tmp/cerber_test.pcap &
# replace 1.2.3.4 with the destination you'll send to (or omit host filter)

```

2.  Send UDP payload (on Linux):

```
# send to localhost:9999
printf 'hiabcdef0' | nc -u -w1 127.0.0.1 9999

```

Or from another box:

```
printf 'hiabcdef0' | nc -u -w1 TARGET_IP 9999

```

3.  Stop capture (`sudo pkill tcpdump`) and run Snort against `/tmp/cerber_test.pcap`.

If you don’t have `nc` with `-u`, you can use `socat`:

```
printf 'hiabcdef0' | socat - UDP:127.0.0.1:9999

```

* * *

## C — Generate a test PCAP for **Ursnif** (HTTP style)

We must create a TCP connection that contains `/images/` near start, includes `_2F` and `_2B`, and a User-Agent string similar to `Mozilla/4.0 (compatible; MSIE 8.0; Windows NT)` and *no* Accept/Cookie/Referer headers.

Simplest reliable method: craft the raw HTTP POST/GET and send via `nc` to a listening HTTP server (or to a TCP port) so TCP handshake + payload is captured.

1.  Start a TCP listener (simple HTTP server) and capture:

```
# start tcpdump
sudo tcpdump -i any tcp port 8080 -w /tmp/ursnif_test.pcap &
# start a listener to accept the raw request so the TCP connection completes
nc -l 8080 > /dev/null &

```

2.  Craft raw HTTP request and send:

```
printf 'GET /images/_2F_something_2B HTTP/1.1\r\nHost: victim\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT)\r\n\r\n' | nc 127.0.0.1 8080

```

This request:

- Has URI `/images/_2F_something_2B` so `/images/` occurs early;
    
- Has the specific User-Agent;
    
- Includes **no** `Accept`, `Referer`, or `Cookie` headers (we did not send them).
    

3.  Stop capture, then run Snort on `/tmp/ursnif_test.pcap`.

If your rule expects those strings in headers rather than URI, adjust the raw request accordingly. The raw `printf` gives you full control over which headers are present or omitted.

* * *

## D — Generate a test PCAP for **Patchwork (HTTP POST)** rule

We want a POST to `.php?profile=` and a body containing `ddager=` followed immediately by `&r1=`.

1.  Start capture + listener:

```
sudo tcpdump -i any tcp port 8081 -w /tmp/patchwork_test.pcap &
nc -l 8081 > /dev/null &

```

2.  Send a raw POST (no `Accept` or `Referer` headers):

```
printf 'POST /whatever.php?profile=foo HTTP/1.1\r\nHost: victim\r\nContent-Length: 20\r\nUser-Agent: curl/7.##\r\n\r\nddager=&r1=XXXX\r\n' | nc 127.0.0.1 8081

```

Adjust `Content-Length` to the exact body length (or let the server ignore it)—the important part is `ddager=&r1=` appearing in the client body and omitted `Accept`/`Referer`.

3.  Stop capture, run Snort on the pcap.

Note: Using `curl` easily adds common headers (like `Accept: */*`) — to test header absence precisely, prefer `printf` + `nc` so you can omit headers.

* * *

## E — Generate a test PCAP for **Patchwork (SSL / cert CN)** rule

This rule looks inside the certificate for CN `toigetgf`. We can make a TLS server that presents a cert whose CN is exactly `toigetgf`.

1.  Create a self-signed cert with CN `toigetgf`:

```
openssl req -x509 -newkey rsa:2048 -nodes \
  -keyout /tmp/key.pem -out /tmp/cert.pem \
  -days 1 -subj "/CN=toigetgf"

```

2.  Start a TLS server and capture:

```
sudo tcpdump -i any port 443 -w /tmp/patchwork_ssl.pcap &
# Run an OpenSSL server on port 4443 to avoid needing root on some hosts
openssl s_server -accept 4443 -cert /tmp/cert.pem -key /tmp/key.pem &
# make a client connect to it (this triggers handshake + cert exchange)
openssl s_client -connect 127.0.0.1:4443 -brief < /dev/null

```

3.  Stop capture and run Snort on `/tmp/patchwork_ssl.pcap`. The certificate bytes will be in the handshake packets, and the rule’s hex sequence should match.

* * *

# 4) Running Snort against the generated PCAP

Example command used in your original:

```
sudo snort -c /root/snorty/etc/snort/snort.lua \
  --daq-dir /usr/local/lib/daq \
  -R /home/htb-student/local.rules \
  -r /tmp/ursnif_test.pcap -A cmg

```

- `-r file.pcap` reads the pcap.
    
- `-R local.rules` loads your test rules (be sure rules are uncommented).
    
- `-A cmg` sets alert output format (console/management format).
    

If you want to run Snort live:

```
sudo snort -c /root/snorty/etc/snort/snort.lua -i eth0 -R local.rules -A console

```

Replace `eth0` with the correct interface.

* * *

# 5) Practical tips & recommendations

- **Prefer protocol-specific buffers** when possible: `http_uri`, `http_client_body`, `http_header` are more robust than raw `content` against TCP segmentation and packet reordering.
    
- **Use `fast_pattern`** on a short, invariant substring to speed up matching.
    
- **Avoid tiny `depth` values** unless you *know* the string is always that close to the packet start.
    
- **Be careful** with `content:!"…" (negation)** — verifying header absence works best when you use normalized buffers` (http_header\`) and you know how the client behaves.
    
- **Use `pcre` when you need anchors, ranges, or more complex ordering** (e.g., start-of-buffer `^`, end-of-buffer `$`).
    
- **Test both ways: real pcap and live traffic.** It’s easy to craft traffic with `printf|nc` and capture with `tcpdump` as shown.
    
- **When detecting certificates,** consider certificate parsing limitations—if you need robust detection, consider a preprocessor or metadata extraction to parse subject fields, or use broader patterns (subjectAltName).
    

* * *

# 6) Short, copyable examples 

Cerber UDP send:

```
sudo tcpdump -i any udp -w /tmp/cerber_test.pcap &
printf 'hiabcdef0' | nc -u -w1 127.0.0.1 9999
sudo pkill -f tcpdump
sudo snort -c /root/snorty/etc/snort/snort.lua -R local.rules -r /tmp/cerber_test.pcap -A cmg

```

Patchwork HTTP POST (raw):

```
sudo tcpdump -i any tcp port 8081 -w /tmp/patchwork_test.pcap &
nc -l 8081 > /dev/null &
printf 'POST /x.php?profile=1 HTTP/1.1\r\nHost: a\r\nContent-Length:13\r\n\r\nddager=&r1=ab\r\n' | nc 127.0.0.1 8081
sudo pkill -f tcpdump
sudo snort -c /root/snorty/etc/snort/snort.lua -R local.rules -r /tmp/patchwork_test.pcap -A cmg

```

SSL certificate test:

```
openssl req -x509 -newkey rsa:2048 -nodes -keyout /tmp/key.pem -out /tmp/cert.pem -subj "/CN=toigetgf" -days 1
sudo tcpdump -i any port 4443 -w /tmp/patchwork_ssl.pcap &
openssl s_server -accept 4443 -cert /tmp/cert.pem -key /tmp/key.pem &
openssl s_client -connect 127.0.0.1:4443 < /dev/null
sudo pkill -f tcpdump
sudo snort -c /root/snorty/etc/snort/snort.lua -R local.rules -r /tmp/patchwork_ssl.pcap -A cmg

```

* * *

&nbsp;