---
title: 02. Developing YARA Rules
updated: 2025-10-28 04:24:52Z
created: 2025-10-24 03:09:56Z
---

# Developing YARA Rules 

This section provides a hands-on walkthrough of both **manual** and **automated** YARA rule creation. It covers practical examples, tools, and best practices for building reliable detection signatures for malware families and behaviors.

* * *

## 1\. Introduction to YARA Rule Development

YARA rules help analysts **identify malware samples** by defining patterns that appear in files — such as strings, file structures, or behaviors. This section demonstrates:

- **Manual rule crafting** using string analysis and PE attributes.
    
- **Automated rule generation** using `yarGen`.
    
- **Advanced techniques** involving imphashes, entropy analysis, and .NET metadata extraction.
    

The examples are run inside a target environment with samples stored under:

`/home/htb-student/Samples/YARASigma`

* * *

## 2\. Manual Rule Example – Detecting UPX-Packed Files

**Sample:** `svchost.exe`  
**Goal:** Identify executables packed with UPX.

### Process:

1.  Use the `strings` command:
    
2.  `strings svchost.exe`
    
    Key indicators: `UPX0`, `UPX1`, `UPX2`.
    
3.  Build a simple YARA rule:
    

```
rule UPX_packed_executable
{
    meta:
        description = "Detects UPX-packed executables"

    strings:
        $string_1 = "UPX0"
        $string_2 = "UPX1"
        $string_3 = "UPX2"

    condition:
        all of them
}

```

### Explanation:

- **Meta:** Describes rule purpose.
    
- **Strings:** Defines what to search for.
    
- **Condition:** Triggers if all three strings are found.
    

**Purpose:** This rule detects files compressed with the **UPX packer**, which is often used to obfuscate malware.

* * *

## 3\. Automated YARA Rule Generation – Using yarGen

**Tool:** `yarGen` (by Florian Roth)  
**Sample:** `dharma_sample.exe`

### About yarGen:

- Automates rule generation by extracting strings unique to malware.
    
- Filters out common benign strings using a **goodware database**.
    
- Located in: `/home/htb-student/yarGen-0.23.4`
    

### Setup:

```
pip install -r requirements.txt
python yarGen.py --update

```

Downloads goodware/opcode databases (~913 MB).

### Execution:

```
python3 yarGen.py -m /home/htb-student/temp -o htb_sample.yar

```

### Output Rule:

```
rule dharma_sample {
   meta:
      description = "temp - file dharma_sample.exe"
      author = "yarGen Rule Generator"
   strings:
      $x1 = "C:\\crysis\\Release\\PDB\\payload.pdb" fullword ascii
      ...
   condition:
      uint16(0) == 0x5a4d and filesize < 300KB and
      1 of ($x*) and 4 of them
}

```

### Test:

`yara htb_sample.yar /home/htb-student/Samples/YARASigma`

### Result:

Detected:

- `dharma_sample.exe`
    
- `pdf_reader.exe`
    
- `microsoft.com`
    
- `check_updates.exe`
    
- `KB5027505.exe`
    

**Takeaway:**  
`yarGen` is excellent for quickly creating draft rules but still requires **manual refinement** to improve accuracy and reduce false positives.

* * *

## 4\. Manual Rule Example – APT17’s ZoxPNG RAT

**Sample:** `legit.exe`  
**Goal:** Detect APT17’s ZoxPNG variant.

### Analysis Steps:

1.  Run `strings legit.exe` → Find:
    
    - URLs (`http://%s/imgres?...`)
        
    - HTTP headers (`Content-Type: image/x-png`)
        
    - User-Agent strings
        
2.  Compute **imphash**:
    
    ```
    python3 imphash_calc.py /home/htb-student/Samples/YARASigma/legit.exe
    
    ```
    
    Output: `414bbd566b700ea021cfae3ad8f4d9b9`
    
    &nbsp;
    
3.  Reference sample hashes from **Intezer** and size limit (<200KB).
    

### Rule:

```
import "pe"

rule APT17_Malware_Oct17_Gen {
   meta:
      description = "Detects APT17 malware"
      author = "Florian Roth (Nextron Systems)"
   strings:
      $x1 = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0)" ascii
      $s3 = "Cookie: SESSIONID=%s" fullword ascii
      $s5 = "Content-Type: image/x-png" fullword ascii
   condition:
      uint16(0) == 0x5a4d and filesize < 200KB and (
         pe.imphash() == "414bbd566b700ea021cfae3ad8f4d9b9" or
         1 of ($x*) or
         6 of them
      )
}

```

### Rule Highlights:

- Imports **PE module** for imphash detection.
    
- Matches small PE files (<200KB).
    
- Uses a **multi-trigger condition** for flexibility.
    

* * *

## 5\. Manual Rule Example – Turla’s Neuron (.NET Malware)

**Sample:** `Microsoft.Exchange.Service.exe`  
**Goal:** Identify Neuron Service component used by Turla.

### Analysis:

1.  Neuron is a **.NET assembly** → analyzed via:
    
2.  ```
    monodis --output=code Microsoft.Exchange.Service.exe
    
    ```
    
    or better: use **dnSpy** to view C# code.
    
3.  Extract class and method names:
    
    - Classes: `StorageUtils`, `StorageFile`, `ServerConfig`, `W3WPDIAG`
        
    - Functions: `EncryptScript`, `ExecCMD`, `KillOldThread`
        

### Rule:

```
rule neuron_functions_classes_and_vars {
 meta:
   description = "Detection of Neuron based on .NET classes/functions"
   author = "NCSC UK"
 strings:
   $class1 = "StorageUtils" ascii
   $func5 = "ExecCMD" ascii
   $func4 = "EncryptScript" ascii
   $dotnetMagic = "BSJB" ascii
 condition:
   (uint16(0) == 0x5A4D and uint16(uint32(0x3c)) == 0x4550)
   and $dotnetMagic and 6 of them
}

```

### Key Points:

- **`BSJB` magic** marks .NET assemblies.
    
- The rule requires at least **six unique strings** to reduce false positives.
    
- Confirms the file is a valid PE and .NET binary.
    

* * *

## 6\. Manual Rule Example – Stonedrill (Shamoon 2.0)

**Sample:** `sham2.exe`  
**Goal:** Detect high-entropy encrypted resources used in Shamoon 2.0.

### Tool:

```
python3 entropy_pe_section.py -f sham2.exe

```

Output shows `.rsrc` entropy ≈ **7.97**, indicating encryption.

### Rule:

```
import "pe"
import "math"

rule susp_file_enumerator_with_encrypted_resource_101 {
meta:
  description = "Detects encrypted resource 101 (Stonedrill)"
  author = "Kaspersky Lab"
strings:
  $a1 = "FindFirstFile" ascii wide nocase
  $a2 = "FindNextFile" ascii wide nocase
  $a3 = "FindResource" ascii wide nocase
  $a4 = "LoadResource" ascii wide nocase
condition:
  uint16(0) == 0x5A4D and
  all of them and
  filesize < 700000 and
  pe.number_of_sections > 4 and
  pe.number_of_signatures == 0 and
  pe.number_of_resources > 1 and pe.number_of_resources < 15 and
  for any i in (0..pe.number_of_resources - 1):
     (math.entropy(pe.resources[i].offset, pe.resources[i].length) > 7.8 and
      pe.resources[i].id == 101 and
      pe.resources[i].length > 20000)
}

```

### Detection Logic:

- Scans **resource sections** with high entropy (>7.8).
    
- Targets **resource ID 101**, typical for Stonedrill.
    
- Confirms file is **unsigned**, multi-sectioned, and under **700KB**.
    

* * *

## 7\. Key Tools Used

| Tool | Purpose |
| --- | --- |
| `strings` | Extract readable strings from binaries |
| `yarGen` | Automatically generate YARA rules |
| `yara` | Test and apply YARA rules |
| `imphash_calc.py` | Compute PE import hashes |
| `monodis`, `dnSpy` | Reverse .NET assemblies |
| `entropy_pe_section.py` | Measure section entropy to find encryption |
| YARA modules: `pe`, `math` | Inspect PE attributes and perform math operations |

* * *

## 8\. Best Practices for YARA Development

- **Combine techniques**: string analysis, imphash, entropy, and structural checks.
    
- **Use conditions carefully**: avoid overly generic rules; include PE and size checks.
    
- **Refine yarGen output** manually — remove redundant or common strings.
    
- **Add meta fields** (`description`, `author`, `reference`, `date`, `hashes`) for clarity.
    
- **Test across benign and malicious corpora** to balance detection accuracy.
    
- **Version control your rules** for easy updates and collaboration.
    

* * *

## 9\. Recommended Resources

- **Official YARA Documentation:**  
    https://yara.readthedocs.io/
    
- **Kaspersky YARA Guides:** Effective detection rule design.
    
- **Florian Roth’s Blog Series:**  
    *“How to Write Simple but Sound YARA Rules”* (Parts 1–3)
    

* * *

## 10\. Final Insight

YARA rule development is both **art and science**.  
Automation tools like `yarGen` accelerate pattern extraction, but **human analysis** ensures accuracy. The best results come from combining:

- Automated pre-selection (using yarGen).
    
- Manual refinement (contextual analysis, testing, tuning).
    
- Structural intelligence (PE, entropy, .NET metadata).
    

This hybrid approach produces **robust, reliable YARA rules** capable of detecting advanced malware families while minimizing false positives.

&nbsp;