---
title: 03. Static Analysis on Linux
updated: 2025-10-17 16:17:59Z
created: 2025-10-16 05:11:39Z
---

# Static Analysis on Linux

Static analysis is the process of examining malware **without executing it**. Instead of running the sample, analysts inspect its **code, metadata, and structure** to uncover useful information about its behavior and origin. This stage is typically the **first step** before performing dynamic or behavioral analysis.

The main goal is to extract key details such as:

- File type
    
- File hash
    
- Strings and embedded data
    
- Packer or obfuscation indicators
    
- Imported and exported functions
    
- Assembly code structure
    

These elements help build an early profile of the malware — allowing analysts to classify it, identify variants, and determine if it’s been seen before.

* * *

## Overview of the Static Analysis Process

A common workflow for static malware analysis includes:

1.  Input malware sample
    
2.  Determine file type
    
3.  Fingerprint (generate file hashes)
    
4.  Detect packers or compression
    
5.  Extract readable strings
    
6.  Inspect headers and metadata
    
7.  Classify based on indicators
    
8.  Develop detection or YARA rules
    

* * *

# Identifying the File Type

The first step in any static analysis is to determine what kind of file you’re dealing with. File extensions (like `.exe` or `.dll`) can be misleading, so we rely on **file signatures** and **headers** instead. This ensures that the right analysis tools are used later.

Example: analyzing a Windows malware sample named `Ransomware.wannacry.exe` located in  
`/home/htb-student/Samples/MalwareAnalysis/`

`file /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe`

**Output:**

`PE32 executable (GUI) Intel 80386, for MS Windows`

This confirms that the file is a **32-bit Windows Portable Executable (PE)**.

To manually confirm, you can inspect the file header using `hexdump`:

`hexdump -C /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe | more`

The first two bytes of the file (`4D 5A`) correspond to the ASCII characters `MZ` — a **magic number** that identifies Windows executables.  
The initials “MZ” refer to **Mark Zbikowski**, one of the original architects of MS-DOS.

* * *

# Malware Fingerprinting

Next, we generate **cryptographic hashes** (MD5, SHA1, SHA256) to uniquely identify the sample.  
This allows analysts to track it across systems, correlate it with known threats, and share it as an **Indicator of Compromise (IoC)**.

### Example Commands

**MD5 Hash:**

`md5sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe`

**Output:**

`db349b97c37d22f5ea1d1841e3c89eb4`

**SHA256 Hash:**

`sha256sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe`

**Output:**

`24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c`

* * *

# File Hash Lookup

The next step is to search the hash on **online malware databases**, such as VirusTotal

, which aggregates results from many antivirus engines.  
Submitting the SHA256 hash of the WannaCry sample reveals it’s recognized by nearly all major vendors as **ransomware or trojan.wannacry**.

While hashes like MD5 and SHA256 uniquely identify *exact* files, they **change if the binary is modified**, even slightly. This means traditional hashing can’t detect *variants* of the same malware.

* * *

# Detecting Similar Malware with IMPHASH

To overcome the limitation of file hashes, analysts use **Import Hashing (IMPHASH)**.

An IMPHASH is a cryptographic hash generated from the **imported functions** of a PE file.  
It is computed by:

1.  Converting all imported DLL and function names to lowercase.
    
2.  Sorting them alphabetically.
    
3.  Concatenating the names.
    
4.  Generating an MD5 hash from the resulting string.
    

Two executables with the **same import functions and order** will share the same IMPHASH — making it useful for linking **related malware variants**.

You can find the IMPHASH under the *Details* tab in VirusTotal results, or compute it manually using Python.

### Example Python Script

```
import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
print(pe.get_imphash())

```

To use it:

```
python3 imphash_calc.py /home/Samples/MalwareAnalysis/Ransomware.wannacry.exe

```

**Output:**

```
9ecee117164e0b870a53dd187cdd7174

```

This matches the IMPHASH displayed by VirusTotal, confirming the file’s import structure.

* * *

# Fuzzy Hashing (SSDEEP)

Fuzzy hashing, also known as **context-triggered piecewise hashing (CTPH)**, is a method designed to measure **similarity between files**, rather than produce a single unique hash. It divides a file into smaller fixed-size chunks, computes a hash for each block, and then combines these to form a “fuzzy” hash that reflects overall content similarity.

Unlike cryptographic hashes (MD5/SHA256) which change completely if even one byte changes, **SSDEEP** allows comparison between files to determine how similar they are.

* * *

## How It Works

- The algorithm splits the file into equal-sized blocks.
    
- Each block is hashed individually.
    
- The combined block hashes form the fuzzy hash.
    
- The similarity comparison emphasizes **long, shared block sequences**, making it effective for detecting **modified or variant malware**.
    

* * *

## Example: Checking an SSDEEP Hash

We can check the SSDEEP hash of the WannaCry ransomware sample as follows:

```
ssdeep /home/Samples/MalwareAnalysis/Ransomware.wannacry.exe

```

**Output:**

```
ssdeep,1.1--blocksize:hash:hash,filename
98304:wDqPoBhz1aRxcSUDk36SAEdhvxWa9P593R8yAVp2g3R:wDqPe1Cxcxk3ZAEUadzR8yc4gB,"/home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe"

```

This value can also be found in the *Details* tab of the VirusTotal analysis results.

* * *

## Comparing Multiple Samples

You can compare multiple malware samples in a directory using SSDEEP’s **pretty matching** mode:

```
ssdeep -pb *

```

**Output:**

```
potato.exe matches svchost.exe (99)
svchost.exe matches potato.exe (99)

```

- `-p`: pretty matching mode (readable format)
    
- `-b`: show only filenames, not full paths
    
- A similarity score of **99%** means the samples are almost identical.
    

* * *

## Summary

Fuzzy hashing allows analysts to:

- Detect near-identical or slightly modified malware variants
    
- Identify related samples within a malware family
    
- Support clustering of malicious files in large datasets
    

However, it’s **less effective against packed or heavily obfuscated binaries**, where block content changes significantly.

* * *

# Section Hashing (Hashing PE Sections)

**Section hashing** involves calculating cryptographic hashes (MD5, SHA256) for each **section** of a Portable Executable (PE) file (like `.text`, `.rdata`, `.data`, `.rsrc`).  
This helps analysts identify which parts of the malware have been modified between versions.

* * *

## Purpose

Attackers often make small changes to evade signature detection. Section hashing focuses on **individual sections**, allowing analysts to pinpoint changes to code or data even when the overall file hash differs.

If two samples share identical section hashes, those sections are unchanged.

* * *

## Example Python Code

We can use the `pefile` Python module to perform section hashing:

```
import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)

for section in pe.sections:
    print(section.Name, "MD5 hash:", section.get_hash_md5())
    print(section.Name, "SHA256 hash:", section.get_hash_sha256())

```

To run it:

```
python3 section_hashing.py /home/MalwareAnalysis/Ransomware.wannacry.exe

```

**Output:**

```
b'.text\x00\x00\x00' MD5 hash: c7613102e2ecec5dcefc144f83189153
b'.text\x00\x00\x00' SHA256 hash: 7609ecc798a357dd1a2f0134f9a6ea06511a8885ec322c7acd0d84c569398678
b'.rdata\x00\x00' MD5 hash: d8037d744b539326c06e897625751cc9
b'.rdata\x00\x00' SHA256 hash: 532e9419f23eaf5eb0e8828b211a7164cbf80ad54461bc748c1ec2349552e6a2
b'.data\x00\x00\x00' MD5 hash: 22a8598dc29cad7078c291e94612ce26
b'.data\x00\x00\x00' SHA256 hash: 6f93fb1b241a990ecc281f9c782f0da471628f6068925aaf580c1b1de86bce8a
b'.rsrc\x00\x00\x00' MD5 hash: 12e1bd7375d82cca3a51ca48fe22d1a9
b'.rsrc\x00\x00\x00' SHA256 hash: 1efe677209c1284357ef0c7996a1318b7de3836dfb11f97d85335d6d3b8a8e42

```

* * *

## Key Insights

- Matching section hashes = unchanged section
    
- Mismatched hashes = altered or injected code
    
- Focus further analysis on changed sections (especially `.text` and `.rsrc`)
    

* * *

## Limitations

- Section names can be renamed or randomized
    
- Packed or encrypted executables often invalidate section hashes
    
- Most effective when analyzing unpacked or partially deobfuscated samples
    

* * *

# String Analysis

String analysis extracts **human-readable text** from a binary — both **ASCII** and **Unicode** — providing valuable hints about the malware’s behavior, configuration, and authorship.

* * *

## What to Look For

Strings may reveal:

- File or directory names
    
- URLs, IP addresses, or domains
    
- Registry keys and system paths
    
- Windows API function calls
    
- Command-line arguments
    
- Debug information (like PDB paths)
    

These artifacts can help **link malware samples to known families** or **specific threat actors**.

* * *

## Example: Extracting Strings with Linux

```
strings -n 15 /home/Samples/MalwareAnalysis/dharma_sample.exe

```

**Output (excerpt):**

```
WaitForSingleObject
InitializeCriticalSectionAndSpinCount
LeaveCriticalSection
EnterCriticalSection
C:\crysis\Release\PDB\payload.pdb
0123456789ABCDEF

```

- `-n 15` → only print strings of at least 15 characters
    
- The discovered **PDB path** (`C:\crysis\Release\PDB\payload.pdb`) can help link this sample to the **Dharma/Crysis ransomware family**.
    

* * *

## Advanced Tool: FLOSS (FireEye Labs Obfuscated String Solver)

Malware often hides strings using encoding or obfuscation. **FLOSS** automatically detects and decodes such strings, going beyond what the `strings` command can find.

Example command:

```
floss /home/Samples/MalwareAnalysis/dharma_sample.exe

```

**Output Summary (truncated):**

```
FLARE FLOSS RESULTS (v2.0.0)
-------------------------------------------------------
| file path: /home/htb-student/Samples/MalwareAnalysis/dharma_sample.exe |
| static strings: 720   | stack strings: 1   | decoded strings: 7 |
-------------------------------------------------------
EEED
uBIA
%sh(
0123456789ABCDEF
    
```

FLOSS categorizes strings as:

- **Static strings**: directly stored in the binary
    
- **Stack strings**: built dynamically in memory
    
- **Tight strings / decoded strings**: revealed through emulated deobfuscation
    

* * *

## Summary

String analysis provides quick insights into:

- Malware functionality (through API names)
    
- Persistence or configuration paths
    
- Network indicators for detection and blocking
    
- Possible attribution via unique metadata
    

When combined with SSDEEP and section hashing, string analysis forms a **core part of static malware triage**, enabling correlation and deeper investigation before execution-based (dynamic) testing.

* * *

&nbsp;

# Unpacking UPX-Packed Malware in Static Analysis

## What is Packing and Why Do Malware Authors Use It?

Malware samples are often *packed*—meaning they are compressed or obfuscated using software like UPX (Ultimate Packer for Executables). Packing serves several purposes:

- **Code Obfuscation**: Hides the original code, making it harder for reverse engineers and analysts to understand what the malware does.
    
- **Size Reduction**: Compresses the binary, making it smaller and faster to download or transfer.
    
- **Detection Evasion**: Thwarts static detection techniques and complicates string extraction or disassembly.
    

Packed malware essentially wraps the real payload inside a small **loader stub**. This stub decompresses or reconstructs the original code at runtime, so what you see statically isn’t the real malicious content.

* * *

## Recognizing UPX Packing Using the `strings` Command

Let's inspect a suspicious executable called `credential_stealer.exe` using the `strings` utility:

`strings /home/htb-student/Samples/MalwareAnalysis/packed/credential_stealer.exe`

**Sample Output:**

`!This program cannot be run in DOS mode.UPX0UPX1UPX2UPX!...`

**Key Observations:**

- The presence of strings like `UPX0`, `UPX1`, and `UPX!` indicates that the file is likely packed using **UPX**.
    
- Aside from these markers, the output contains mostly gibberish—no meaningful strings or clues about functionality. This is typical of packed binaries.
    

* * *

# Unpacking the Malware Using UPX

To reveal the original contents, we unpack it using the **UPX tool**:

`cd /home/htb-student/Samples/MalwareAnalysis/packedupx -d -o unpacked_credential_stealer.exe credential_stealer.exe`

**Sample Output:**

`File size Ratio Format Name16896 <- 8704 51.52% win64/pe unpacked_credential_stealer.exeUnpacked 1 file.`

This tells us:

- The file has been successfully unpacked.
    
- The original size was compressed by about half.
    

* * *

## Analyzing the Unpacked Binary

Now that we have an unpacked version, we can run `strings` again:

`strings unpacked_credential_stealer.exe`

**Sample Output (Snippets):**

`SeDebugPrivilegelsass.exeLSASS Memory is dumped successfullyMiniDumpWriteDumpOpenProcessVirtualProtectADVAPI32.dlldbghelp.dllKERNEL32.DLL...`

**What We Learn Now:**

- **Human-readable strings** related to process manipulation, privilege escalation, and credential dumping (e.g., `lsass.exe`, `MiniDumpWriteDump`) are now visible.
    
- References to key **Windows APIs** and **DLLs** confirm the malware's intent and target environment.
    
- Static analysis tools like `strings`, `Ghidra`, or `PE viewers` will now have more usable data to work with.
    

* * *

## Summary

| Step | Description |
| --- | --- |
| **1\. Detection** | Used `strings` to check for UPX markers (`UPX0`, `UPX1`, etc.) |
| **2\. Unpacking** | Ran `upx -d` to decompress the binary |
| **3\. Re-analysis** | Re-ran `strings` and found meaningful information for further investigation |

&nbsp;

&nbsp;