---
title: 02. Windows Internals
updated: 2025-10-28 04:26:14Z
created: 2025-10-16 03:55:19Z
---

# 1\. Windows Internals for Malware Analysis

A deep understanding of Windows internals is essential for malware analysis. Malware interacts with the same OS mechanisms as legitimate software, so analysts must know how Windows transitions between **user mode** and **kernel mode**, how **API calls** become **system calls**, and where access checks occur.

* * *

# 2\. Windows Operating Modes

Windows operates in two distinct modes that separate privilege levels and access to system resources.

## 2.1 User Mode

User mode is where most applications and services operate. It provides a controlled environment with limited access to hardware.

**Characteristics:**

- Restricted access to memory and devices.
    
- Programs must use **Windows APIs** to interact with system resources.
    
- Processes are **isolated** from one another for stability and security.
    

**Typical malware actions:**

1.  Manipulating files or registry keys.
    
2.  Injecting code into other user-mode processes.
    
3.  Attempting to gain **privilege escalation** to kernel mode.
    

**Example:**  
A malicious process calls `OpenProcess()` and `WriteProcessMemory()` to inject payloads into another running process.

* * *

## 2.2 Kernel Mode

Kernel mode is the most privileged level where the **Windows kernel**, **drivers**, and **core OS components** run.

**Characteristics:**

- Full access to all hardware and memory.
    
- Used by the OS to execute low-level operations.
    
- A crash in kernel mode can trigger a **Blue Screen of Death (BSOD)**.
    

**Typical malware actions:**

1.  Loading unsigned or malicious drivers.
    
2.  Hooking system calls or kernel functions.
    
3.  Hiding processes, files, or registry keys from detection.
    

**Example:**  
A rootkit installs a driver that hooks the **SSDT** to intercept calls to hide its own files from user-mode tools.

* * *

# 3\. Windows Architecture Overview

Windows architecture is divided into **User-Mode Components** and **Kernel-Mode Components**, each handling different responsibilities.

* * *

## 3.1 User-Mode Components

| Component | Description | Example Processes / DLLs |
| --- | --- | --- |
| **System Support Processes** | Handle essential OS startup and maintenance functions. | `smss.exe`, `winlogon.exe`, `services.exe` |
| **Service Processes** | Host background Windows services. | `svchost.exe`, `spoolsv.exe`, `wuauclt.exe` |
| **User Applications** | Regular programs run by users, communicating via APIs. | `chrome.exe`, `explorer.exe`, `calc.exe` |
| **Environment Subsystems** | Provide runtime environments for applications. | Win32, POSIX, OS/2 |
| **Subsystem DLLs** | Translate high-level API calls into native system calls. | `kernel32.dll`, `user32.dll`, `advapi32.dll`, `ntdll.dll` |

* * *

## 3.2 Kernel-Mode Components

| Component | Description | Primary Function |
| --- | --- | --- |
| **Executive** | Core set of managers providing OS services. | I/O, Object, Process, and Security management |
| **Kernel** | Handles thread scheduling, interrupts, and synchronization. | Low-level resource control |
| **Device Drivers** | Facilitate communication between hardware and OS. | Disk, network, and input drivers |
| **Hardware Abstraction Layer (HAL)** | Provides a uniform interface between hardware and OS. | Hardware independence |
| **Windowing and Graphics (Win32k.sys)** | Manages GUI rendering at the kernel level. | Drawing windows, handling user input |

* * *

# 4\. API Call Flow — From User Mode to Kernel Mode

Malware frequently relies on **Windows API calls** to manipulate system behavior. Understanding this call flow helps analysts trace malicious behavior effectively.

* * *

## 4.1 Example: ReadProcessMemory

The `ReadProcessMemory` API allows a process to read another process’s memory.

```
BOOL ReadProcessMemory(
  HANDLE  hProcess,
  LPCVOID lpBaseAddress,
  LPVOID  lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesRead
);

```

**Purpose:** Used by debuggers and, often, malware to access another process’s address space.

* * *

## 4.2 Step-by-Step Call Flow

1.  The **user application** calls `ReadProcessMemory()` located in `kernel32.dll`.
    
2.  `kernel32.dll` forwards the request to **NTDLL.DLL**.
    
3.  **NTDLL.DLL** invokes the native function `NtReadVirtualMemory`.
    
4.  The **syscall instruction** (`syscall` / `sysenter`) triggers a transition from **user mode** to **kernel mode**.
    
5.  The **System Service Descriptor Table (SSDT)** identifies which kernel function to execute (based on syscall number).
    
6.  The kernel validates the parameters and performs the memory read.
    
7.  The kernel copies data into the caller’s buffer and returns the result.
    
8.  Execution transitions back to **user mode**, returning control to the calling application.
    

* * *

## 4.3 Simplified Flow Diagram

| Layer | Module | Function | Transition |
| --- | --- | --- | --- |
| User Mode | `kernel32.dll` | `ReadProcessMemory()` | Calls → |
| User Mode | `ntdll.dll` | `NtReadVirtualMemory()` | Executes → |
| Kernel Mode | SSDT | Maps syscall number | Dispatch → |
| Kernel Mode | `Nt!NtReadVirtualMemory` | Performs operation | Return → |
| User Mode | Application | Receives result | Done |

* * *

# 5\. The System Service Descriptor Table (SSDT)

The **SSDT** is a critical structure in the Windows kernel that maps **syscall numbers** to their respective kernel-mode routines.

**Key points:**

- Each system call has an **index number**.
    
- The table entry points to the corresponding kernel function.
    
- Example: `NtReadVirtualMemory` might correspond to index `0x3F`.
    
- Malware can **hook** the SSDT to intercept or redirect system calls.
    

**Detection Tip:**  
Compare current SSDT entries against a clean baseline or verify function pointers with kernel debugging tools (e.g., `!ssdt` in WinDbg).

* * *

# 6\. Indicators of Malicious Activity

## 6.1 User-Mode Indicators

| Behavior | Description | Tools for Detection |
| --- | --- | --- |
| Frequent API Calls | Repeated use of `OpenProcess`, `WriteProcessMemory`, etc. | Procmon, API Monitor |
| Code Injection | Injecting payloads into trusted processes. | x64dbg, Process Hacker |
| Registry Modification | Adding persistence keys or hijacking file associations. | Autoruns, RegShot |

* * *

## 6.2 Kernel-Mode Indicators

| Behavior | Description | Tools for Detection |
| --- | --- | --- |
| Unsigned Drivers | Malicious or tampered kernel drivers. | DriverQuery, SigVerif |
| SSDT Hooking | System call redirection by rootkits. | WinDbg (`!chkimg`, `!ssdt`) |
| Hidden Processes | Manipulated kernel lists concealing PIDs. | Volatility (`psxview`, `malfind`) |

* * *

# 7\. Analysis Workflow

## 7.1 User-Mode Investigation Steps

1.  Enumerate running processes (`tasklist`, Process Explorer).
    
2.  Trace API activity using **Procmon** or **x64dbg**.
    
3.  Dump suspicious memory regions for static review.
    
4.  Inspect registry for persistence entries.
    

## 7.2 Kernel-Mode Investigation Steps

1.  List all loaded drivers and verify digital signatures.
    
2.  Use **WinDbg** to check SSDT integrity.
    
3.  Inspect kernel hooks and callbacks for unknown entries.
    
4.  Perform offline forensics with **Volatility** (`ssdt`, `modules`, `callbacks`).
    

* * *

# 8\. Portable Executable (PE) — what it is and why it matters

A Portable Executable (PE) is the Windows file format for executables, DLLs, drivers and similar modules. For malware analysts the PE format reveals structural clues (sections, imports, exports, resources, relocations) that help identify functionality, packing, anti-analysis techniques, and Indicators of Compromise. PE files accommodate a wide variety of data types including `executables (.exe)`, `dynamic link libraries (.dll)`, `kernel modules (.srv)`, `control panel applications (.cpl)`, and many more. The PE file format is fundamentally a data structure containing the vital information required for the Windows OS loader to manage the executable code, effectively loading it into memory.

- `.dll` → Dynamic-link library (code used by other programs).
    
- `.sys` → Device drivers.
    
- `.ocx`, `.cpl`, `.scr` → Specialized forms of DLLs for controls, control panel items, and screensavers.
    
- All of these share the same **PE structure** — they just differ in purpose and entry points.
    

**Quick checklist:**

- Inspect headers (DOS/PE/Optional) for anomalies.
    
- Enumerate sections and their attributes (R/W/X).
    
- Check imports/exports and resource contents.
    
- Measure entropy per section to find packing/encryption.
    

&nbsp;

&nbsp;

* * *

# 9\. Common PE Sections — quick reference table

The table below lists common sections, their purpose, and analyst notes.

| Section | Purpose | Analyst notes |
| ---: | :--- | :--- |
| `.text` | Executable code | Primary target for static and dynamic code analysis; check for exe→DLL thunking or code caves. |
| `.data` | Initialized writable data | Look for suspicious global variables, config blobs or decoded payloads. |
| `.rdata` | Read-only initialized data (strings, imports) | Strings and import tables often reveal C2, API usage, or strings used by malware. |
| `.pdata` | Exception / unwind info | Useful for unpackers and exception-based control-flow obfuscation. |
| `.bss` | Uninitialized data (logical) | Runtime-initialized variables — watch for large allocations at runtime. |
| `.rsrc` | Resources (icons, dialogs, version info) | Embedded resources may hide configs, certificates, or staged payloads. |
| `.idata` | Import table | Primary source to infer capabilities (network, process, registry). |
| `.edata` | Export table | Important for DLL plugins or loaders—exports may expose entrypoints used by other modules. |
| `.reloc` | Relocations | High entropy or removed relocations can indicate manual mapping or anti-analysis. |

**Quick examples:**

- High entropy in `.text` or `.rsrc` → likely packed or encrypted.
    
- Missing or stripped import table → may indicate runtime API resolution or shellcode-style loader.
    

* * *

# 10\. PE analysis practical steps (short recipe)

1.  Parse headers (DOS MZ → PE signature → Optional Header).
    
2.  List sections and attributes (Virtual/Raw sizes, Entropy).
    
3.  Extract import table and map APIs to capabilities.
    
4.  Examine resources (.rsrc) for embedded data.
    
5.  Check digital signature and certificate table.
    
6.  If suspicious packing found, run dynamic unpacking (sandbox or debugger) and re-analyze.
    

* * *

# 11\. Processes — core concepts for analysts

A process is an executing instance of a program and encapsulates memory, handles, threads and security context. Understanding what a process contains helps detect injection, tampering or privilege abuse.

**Key properties (bulleted list):**

- PID (Process Identifier) — unique numeric ID for tracking.
    
- Virtual Address Space (VAS) — per-process view of memory (code, heap, stacks).
    
- Image on disk — the executable file backing the process image.
    
- Handle table — references to system objects (files, registry keys, mutexes).
    
- Access token — identity and privileges (user, groups, SIDs, privileges).
    
- Threads — units of execution within the process.
    

* * *

# 12\. Process indicators and quick checks (checklist)

- Enumerate processes and parents: detect suspicious parent-child chains.
    
- List loaded modules per process: detect injected modules or side-loaded DLLs.
    
- Inspect memory protections (RWX pages): high-risk for code injection.
    
- Check token privileges (SeDebugPrivilege etc.): privilege escalation attempts.
    
- Compare on-disk image hash vs in-memory image: tampering or unpacking.
    

* * *

# 13\. Dynamic-link Library (DLL) — role and attack surface

A DLL is a PE that provides shared functions. Malware uses DLLs for modularity, code reuse, and common injection/loading techniques (DLL search order hijack, reflective DLL injection, export abuse).

**Analyst bullets:**

- Exports show entrypoints other processes may call.
    
- Imports show external APIs the DLL depends on.
    
- DLL characteristics (exports/imports/sections) help classify loaders vs payloads.
    

* * *

# 14\. Import functions — why they matter (table + notes)

Imports reveal *what* a sample can do without executing it. Mapping imported APIs to capabilities is a fast way to triage malware intent.

| API group | Example functions | Likely capability |
| ---: | :--- | :--- |
| Process/Memory | `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, `CreateRemoteThread` | Process injection, code injection, remote execution |
| File I/O | `CreateFile`, `ReadFile`, `WriteFile`, `DeleteFile` | Persistence, data exfiltration, file tampering |
| Registry | `RegOpenKeyEx`, `RegSetValueEx` | Persistence, configuration, autorun changes |
| Networking | `WSASocket`, `connect`, `send`, `recv` | C2 communication, data exfiltration |
| Service Control | `OpenService`, `CreateService`, `StartService` | Service-based persistence (drivers/services) |
| Crypto/Hash | `CryptEncrypt`, `CryptExportKey` | Payload encryption, secure comms, ransomware routines |
| Windows Management | `CreateProcess`, `ShellExecute` | Process creation, execution chains |

**IOC tip:** Imported function names (or hashed import names) are reliable indicators for static detection signatures.

* * *

# 15\. Example: Process injection flow (concise, numbered steps)

This common injection technique can be inferred from imports and observed behavior.

1.  `OpenProcess()` — obtain handle to target process.
    
2.  `VirtualAllocEx()` — allocate memory in target VAS.
    
3.  `WriteProcessMemory()` — write payload/shellcode into the allocated memory.
    
4.  `CreateRemoteThread()` — start execution inside the target process.
    

**What to look for:**

- A process that calls these APIs in this order.
    
- RWX memory pages created in another process.
    
- Mismatch between module list on-disk and memory-mapped modules.
    

* * *

# 16\. Practical validation steps after static findings (short workflow)

1.  If imports suggest injection, instrument a run in a sandbox and trace API calls (Procmon / API monitor).
    
2.  Capture memory of involved processes and search for injected payload signatures.
    
3.  If import table is empty/obfuscated, look for runtime-resolved APIs (GetProcAddress + LoadLibrary patterns or hashed API resolution).
    
4.  For suspected DLL hijacks, enumerate DLL search order and compare loaded module paths vs expected system paths.
    

* * *

# 17\. Short glossary (quick reference)

- PE: Portable Executable format.
    
- VAS: Virtual Address Space.
    
- IAT: Import Address Table — runtime pointers to imported functions.
    
- EAT: Export Address Table — exported functions from a module.
    
- RWX: Read/Write/Execute memory permission (dangerous).
    
- SSDT: System Service Descriptor Table — kernel syscall mapping (from earlier sections).
    

* * *

&nbsp;